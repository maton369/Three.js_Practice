<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Example 11.02 - Simple passes（ESM / 4分割・黒画面修正 + デバッグ + 効果が出ない問題修正）</title>

  <!-- GUI / FPS -->
  <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>

  <!-- importmap -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #WebGL-output { width: 100vw; height: 100vh; }
    canvas { display: block; }

    #debug {
      position: fixed;
      left: 10px;
      top: 52px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(0,0,0,0.72);
      color: #fff;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre;
      z-index: 9999;
      max-width: min(1000px, 92vw);
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="Stats-output"></div>
  <div id="debug"></div>
  <div id="WebGL-output"></div>

  <script type="module">
    /*
      ============================================================
      ✅ 今回の「4つとも変わらない」原因と修正
      ============================================================

      Direct Scene をONにすると4つとも出る＝ viewport/scissor と描画自体はOK。
      しかし composer経由(OFFSCREEN->BLIT)だと「全て同じ」に見える（＝エフェクトが乗っていない）。

      原因はほぼこれ：
      - 先頭の TexturePass が “needsSwap=false のまま” だと、次のパスが読む readBuffer が更新されない。
        つまり
          TexturePass が writeBuffer に baseTex を描く
          しかし swap しない
          次の DotScreen/Bloom/Film が読む readBuffer は「古いまま（多くは黒 or 前フレーム）」
        となり、結果が意図通りのチェーンにならない/エフェクトが効かない。

      ✅ 対策（本修正）
      - 先頭の TexturePass は “必ず swap させる” ために texPass.needsSwap = true を明示する。
        これで「TexturePassで作った“元画像”が readBuffer 側に確定」し、後段パスが正しく入力として読める。

      さらに安定化として
      - 各 composer の最終出力テクスチャは「最後のパス needsSwap に応じて read/write どちらかにある」
        ので、確実に取り出すユーティリティ getComposerOutputTexture() を追加する。
    */

    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { TexturePass } from "three/addons/postprocessing/TexturePass.js";
    import { DotScreenPass } from "three/addons/postprocessing/DotScreenPass.js";
    import { BloomPass } from "three/addons/postprocessing/BloomPass.js";
    import { FilmPass } from "three/addons/postprocessing/FilmPass.js";

    // ------------------------------------------------------------
    // DOM / Stats / HUD
    // ------------------------------------------------------------
    const host = document.getElementById("WebGL-output");
    const statsHost = document.getElementById("Stats-output");
    const debugEl = document.getElementById("debug");

    const stats = new Stats();
    stats.showPanel(0);
    stats.dom.style.position = "fixed";
    stats.dom.style.left = "0px";
    stats.dom.style.top = "0px";
    statsHost.appendChild(stats.dom);

    window.addEventListener("error", (e) => {
      console.error("[window.error]", e.message, e.filename, e.lineno, e.colno, e.error);
    });
    window.addEventListener("unhandledrejection", (e) => {
      console.error("[unhandledrejection]", e.reason);
    });

    // ------------------------------------------------------------
    // Scene / Camera / Renderer
    // ------------------------------------------------------------
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(-10, 15, 25);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0x000000, 1.0);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    if ("outputColorSpace" in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
    else if ("outputEncoding" in renderer) renderer.outputEncoding = THREE.sRGBEncoding;
    host.appendChild(renderer.domElement);

    const gl = renderer.getContext();

    // ------------------------------------------------------------
    // Controls
    // ------------------------------------------------------------
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.dampingFactor = 0.08;
    const clock = new THREE.Clock();

    // ------------------------------------------------------------
    // Lights / Helpers
    // ------------------------------------------------------------
    scene.add(new THREE.AmbientLight(0x686868));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(50, 30, 50);
    scene.add(dir);

    const axes = new THREE.AxesHelper(15);
    axes.visible = false;
    scene.add(axes);

    // ------------------------------------------------------------
    // Earth mesh (texture load status)
    // ------------------------------------------------------------
    const texStatus = { planet: "pending", specular: "pending", normal: "pending" };
    const sphere = createEarthSphere();
    scene.add(sphere);

    // ------------------------------------------------------------
    // baseComposer (RenderPass only) -> produces baseTex
    // ------------------------------------------------------------
    const baseComposer = new EffectComposer(renderer);
    baseComposer.addPass(new RenderPass(scene, camera));

    // ------------------------------------------------------------
    // effect composers (TexturePass + effect)
    // ------------------------------------------------------------
    function makeComposerWithTexturePass(name) {
      const composer = new EffectComposer(renderer);

      // ✅ 重要：TexturePass は先頭で「元画像」を作る役
      //    ここが swap されないと次のパスが正しい入力を読めない。
      const texPass = new TexturePass(null);
      texPass.needsSwap = true; // ★これが今回の「全部同じ」に見える問題の本命修正

      composer.addPass(texPass);
      composer._debugName = name; // HUD用（内部プロパティにしているだけ）
      composer._inputTexturePass = texPass;
      return { composer, texPass };
    }

    // Dot (LL)
    const dot = makeComposerWithTexturePass("dot");
    let dotPass = new DotScreenPass(new THREE.Vector2(0.5, 0.5), 1.57, 1.0);
    dot.composer.addPass(dotPass);

    // Copy (LR)
    const copy = makeComposerWithTexturePass("copy");
    // ※ Copyは TexturePass だけ（=元画像そのまま）

    // Bloom (UL)
    const bloom = makeComposerWithTexturePass("bloom");
    let bloomPass = new BloomPass(3, 25, 5.0, 256);
    bloom.composer.addPass(bloomPass);

    // Film (UR)
    const film = makeComposerWithTexturePass("film");
    const filmPass = new FilmPass(0.8, 0.325, 256, false);
    film.composer.addPass(filmPass);

    // ------------------------------------------------------------
    // ✅ composer の「最終出力テクスチャ」を確実に取る
    // ------------------------------------------------------------
    /*
      EffectComposer は readBuffer / writeBuffer を持ち、
      「最後のパスが needsSwap を要求するかどうか」で結果がどちら側に残るかが変わる。

      - last.needsSwap === true なら swap 後に readBuffer が最終結果になりやすい
      - last.needsSwap === false なら writeBuffer に最終結果が残りやすい

      ここでは “最後のパスneedsSwapで分岐” して確実に取る。
    */
    function getComposerOutputTexture(composer) {
      const passes = composer.passes ?? [];
      const last = passes.length ? passes[passes.length - 1] : null;
      if (!last) return null;

      // renderToScreen を使っていない（offscreen前提）ので、screenケースは無視
      if (last.needsSwap) {
        return composer.readBuffer?.texture ?? null;
      }
      return composer.writeBuffer?.texture ?? composer.readBuffer?.texture ?? null;
    }

    // ------------------------------------------------------------
    // blit: texture -> screen viewport
    // ------------------------------------------------------------
    const blitScene = new THREE.Scene();
    const blitCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const blitMat = new THREE.MeshBasicMaterial({ color: 0xffffff, map: null });
    blitScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), blitMat));

    function blitTextureToScreen(texture) {
      blitMat.map = texture ?? null;
      blitMat.needsUpdate = true;
      renderer.setRenderTarget(null);
      renderer.render(blitScene, blitCamera);
    }

    // ------------------------------------------------------------
    // Film uniforms (layout detect)
    // ------------------------------------------------------------
    function getFilmUniforms() {
      return filmPass.uniforms ?? filmPass.material?.uniforms ?? null;
    }
    function filmLayout() {
      const u = getFilmUniforms();
      if (!u) return { type: "none", keys: [] };
      const keys = Object.keys(u);
      const hasLegacy = ("nIntensity" in u) && ("sIntensity" in u) && ("sCount" in u);
      const hasUnified = ("intensity" in u);
      if (hasLegacy) return { type: "legacy", keys };
      if (hasUnified) return { type: "unified", keys };
      return { type: "unknown", keys };
    }
    function setFilmUniform(name, value) {
      const u = getFilmUniforms();
      if (!u || !u[name]) return;
      u[name].value = value;
    }
    const filmU = filmLayout();

    // ------------------------------------------------------------
    // readPixels debug
    // ------------------------------------------------------------
    const px = new Uint8Array(4);
    function readPixelRGBA(x, y) {
      const yy = Math.max(0, Math.min(gl.drawingBufferHeight - 1, gl.drawingBufferHeight - 1 - y));
      const xx = Math.max(0, Math.min(gl.drawingBufferWidth - 1, x));
      gl.readPixels(xx, yy, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, px);
      return `rgba(${px[0]},${px[1]},${px[2]},${px[3]})`;
    }

    // test quad (viewport sanity)
    const testScene = new THREE.Scene();
    const testCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    testScene.add(new THREE.Mesh(
      new THREE.PlaneGeometry(2, 2),
      new THREE.MeshBasicMaterial({ color: 0xff00ff })
    ));

    // ------------------------------------------------------------
    // GUI
    // ------------------------------------------------------------
    const gui = new dat.GUI();

    const state = {
      // debug
      debug_showAxes: false,
      debug_directScene: false,
      debug_drawTestQuad: false,
      debug_readPixels: true,

      // offscreenのscissor（基本はfalse固定が正解）
      debug_scissorDuringOffscreen: false,

      // bloom
      bloom_strength: 3,
      bloom_kernelSize: 25,
      bloom_sigma: 5.0,
      bloom_resolution: 256,
      applyBloom() {
        bloomPass = new BloomPass(this.bloom_strength, this.bloom_kernelSize, this.bloom_sigma, this.bloom_resolution);
        bloom.composer.passes[1] = bloomPass;
      },

      // dot
      dot_centerX: 0.5,
      dot_centerY: 0.5,
      dot_angle: 1.57,
      dot_scale: 1.0,
      applyDot() {
        dotPass = new DotScreenPass(new THREE.Vector2(this.dot_centerX, this.dot_centerY), this.dot_angle, this.dot_scale);
        dot.composer.passes[1] = dotPass;
      },

      // film
      film_grayscale: false,
      film_intensity: 0.8,           // unified
      film_noiseIntensity: 0.8,       // legacy
      film_scanlinesIntensity: 0.325, // legacy
      film_scanlinesCount: 256,       // legacy
      applyFilm() {
        setFilmUniform("grayscale", this.film_grayscale);
        if (filmU.type === "unified") {
          setFilmUniform("intensity", this.film_intensity);
        } else if (filmU.type === "legacy") {
          setFilmUniform("nIntensity", this.film_noiseIntensity);
          setFilmUniform("sIntensity", this.film_scanlinesIntensity);
          setFilmUniform("sCount", this.film_scanlinesCount);
        } else {
          console.warn("[FilmPass] unknown uniforms:", filmU.keys);
        }
      }
    };

    const dbg = gui.addFolder("Debug");
    dbg.add(state, "debug_showAxes").name("Show Axes").onChange(() => (axes.visible = state.debug_showAxes));
    dbg.add(state, "debug_directScene").name("Direct Scene (no composer)");
    dbg.add(state, "debug_drawTestQuad").name("Draw Test Quad");
    dbg.add(state, "debug_readPixels").name("ReadPixels HUD");
    dbg.add(state, "debug_scissorDuringOffscreen").name("Scissor during OFFSCREEN (test)");
    dbg.open();

    const bloomFolder = gui.addFolder("BloomPass");
    bloomFolder.add(state, "bloom_strength", 1, 10, 0.01).name("strength").onChange(() => state.applyBloom());
    bloomFolder.add(state, "bloom_kernelSize", 1, 100, 1).name("kernelSize").onChange(() => state.applyBloom());
    bloomFolder.add(state, "bloom_sigma", 1, 10, 0.01).name("sigma").onChange(() => state.applyBloom());
    bloomFolder.add(state, "bloom_resolution", 1, 1024, 1).name("resolution").onChange(() => state.applyBloom());

    const filmFolder = gui.addFolder("FilmPass");
    filmFolder.add(state, "film_grayscale").name("grayscale").onChange(() => state.applyFilm());
    if (filmU.type === "unified") {
      filmFolder.add(state, "film_intensity", 0, 3, 0.001).name("intensity").onChange(() => state.applyFilm());
    } else if (filmU.type === "legacy") {
      filmFolder.add(state, "film_noiseIntensity", 0, 3, 0.001).name("noiseIntensity").onChange(() => state.applyFilm());
      filmFolder.add(state, "film_scanlinesIntensity", 0, 1, 0.001).name("scanlinesIntensity").onChange(() => state.applyFilm());
      filmFolder.add(state, "film_scanlinesCount", 0, 2048, 1).name("scanlinesCount").onChange(() => state.applyFilm());
    }

    const dotFolder = gui.addFolder("DotScreenPass");
    dotFolder.add(state, "dot_centerX", 0, 1, 0.001).name("centerX").onChange(() => state.applyDot());
    dotFolder.add(state, "dot_centerY", 0, 1, 0.001).name("centerY").onChange(() => state.applyDot());
    dotFolder.add(state, "dot_angle", 0, Math.PI, 0.001).name("angle").onChange(() => state.applyDot());
    dotFolder.add(state, "dot_scale", 0, 10, 0.001).name("scale").onChange(() => state.applyDot());

    state.applyBloom();
    state.applyDot();
    state.applyFilm();

    // ------------------------------------------------------------
    // render
    // ------------------------------------------------------------
    let frame = 0;
    let lastRGBA = { dot: "", copy: "", bloom: "", film: "" };
    let outPick = { dot: "", copy: "", bloom: "", film: "" };

    renderer.setScissorTest(true);

    function setViewportAndScissor(x, y, w, h) {
      renderer.setViewport(x, y, w, h);
      renderer.setScissor(x, y, w, h);
    }

    function render() {
      requestAnimationFrame(render);
      stats.begin();

      const delta = clock.getDelta();
      orbit.update();
      sphere.rotation.y += 0.002;

      const width = window.innerWidth || 2;
      const height = window.innerHeight || 2;
      const halfW = Math.floor(width / 2);
      const halfH = Math.floor(height / 2);

      // --- 1) 全画面クリア ---
      renderer.autoClear = false;
      setViewportAndScissor(0, 0, width, height);
      renderer.clear(true, true, true);

      // --- 2) 直描画（切り分け用） ---
      if (state.debug_directScene) {
        setViewportAndScissor(0, 0, halfW, halfH);         renderer.render(scene, camera);
        setViewportAndScissor(halfW, 0, halfW, halfH);     renderer.render(scene, camera);
        setViewportAndScissor(0, halfH, halfW, halfH);     renderer.render(scene, camera);
        setViewportAndScissor(halfW, halfH, halfW, halfH); renderer.render(scene, camera);
      } else {
        // ============================================================
        // OFFSCREEN：composerを回す（scissorは基本OFF）
        // ============================================================
        renderer.setScissorTest(state.debug_scissorDuringOffscreen);
        renderer.setViewport(0, 0, width, height);
        renderer.setScissor(0, 0, width, height);

        // (A) baseComposerで元画像
        baseComposer.render(delta);
        const baseTex = baseComposer.readBuffer?.texture ?? null;

        // (B) 元画像を “各TexturePass” に渡す
        dot.texPass.map = baseTex;
        copy.texPass.map = baseTex;
        bloom.texPass.map = baseTex;
        film.texPass.map = baseTex;

        // (C) 各composerを回して「効果込みテクスチャ」を作る
        dot.composer.render(delta);
        copy.composer.render(delta);
        bloom.composer.render(delta);
        film.composer.render(delta);

        // (D) 出力テクスチャ取得（read/writeどちらかを確実に）
        const texDot   = getComposerOutputTexture(dot.composer);
        const texCopy  = getComposerOutputTexture(copy.composer);
        const texBloom = getComposerOutputTexture(bloom.composer);
        const texFilm  = getComposerOutputTexture(film.composer);

        // HUD用：どっちから取ったか（最後のpass needsSwapで決まる）
        outPick.dot   = dot.composer.passes.at(-1)?.needsSwap ? "read" : "write";
        outPick.copy  = copy.composer.passes.at(-1)?.needsSwap ? "read" : "write";
        outPick.bloom = bloom.composer.passes.at(-1)?.needsSwap ? "read" : "write";
        outPick.film  = film.composer.passes.at(-1)?.needsSwap ? "read" : "write";

        // ============================================================
        // SCREEN：象限に貼る（scissor ON）
        // ============================================================
        renderer.setScissorTest(true);

        // 左下：Dot
        setViewportAndScissor(0, 0, halfW, halfH);
        if (state.debug_drawTestQuad) renderer.render(testScene, testCam);
        blitTextureToScreen(texDot);

        // 右下：Copy
        setViewportAndScissor(halfW, 0, halfW, halfH);
        if (state.debug_drawTestQuad) renderer.render(testScene, testCam);
        blitTextureToScreen(texCopy);

        // 左上：Bloom
        setViewportAndScissor(0, halfH, halfW, halfH);
        if (state.debug_drawTestQuad) renderer.render(testScene, testCam);
        blitTextureToScreen(texBloom);

        // 右上：Film
        setViewportAndScissor(halfW, halfH, halfW, halfH);
        if (state.debug_drawTestQuad) renderer.render(testScene, testCam);
        blitTextureToScreen(texFilm);
      }

      // readPixels（象限中心）
      frame++;
      if (state.debug_readPixels && frame % 30 === 0) {
        const cxL = Math.floor(halfW / 2);
        const cxR = halfW + Math.floor(halfW / 2);
        const cyB = Math.floor(halfH / 2);
        const cyT = halfH + Math.floor(halfH / 2);
        lastRGBA.dot   = readPixelRGBA(cxL, cyB);
        lastRGBA.copy  = readPixelRGBA(cxR, cyB);
        lastRGBA.bloom = readPixelRGBA(cxL, cyT);
        lastRGBA.film  = readPixelRGBA(cxR, cyT);
      }

      // HUD
      if (frame % 10 === 0) {
        const info = renderer.info;
        const baseTexOk = !!(baseComposer.readBuffer && baseComposer.readBuffer.texture);
        debugEl.textContent =
          `--- DEBUG HUD ---\n` +
          `mode: ${state.debug_directScene ? "DIRECT(scene)" : "OFFSCREEN(composer) -> BLIT(screen)"}\n` +
          `scissorDuringOffscreen: ${state.debug_scissorDuringOffscreen} (should be false)\n` +
          `filmUniformLayout: ${filmU.type} keys=${filmU.keys.join(",")}\n` +
          `textures: planet=${texStatus.planet}, specular=${texStatus.specular}, normal=${texStatus.normal}\n` +
          `baseTex: ${baseTexOk}\n` +
          `outPick: dot=${outPick.dot}, copy=${outPick.copy}, bloom=${outPick.bloom}, film=${outPick.film}\n` +
          `renderer.info: calls=${info.render.calls}, tris=${info.render.triangles}, tex=${info.memory.textures}\n` +
          `gl: ${gl.getParameter(gl.VERSION)}\n` +
          `glsl: ${gl.getParameter(gl.SHADING_LANGUAGE_VERSION)}\n` +
          (state.debug_readPixels
            ? `readPixels: dot=${lastRGBA.dot} copy=${lastRGBA.copy} bloom=${lastRGBA.bloom} film=${lastRGBA.film}\n`
            : `readPixels: (disabled)\n`);
      }

      stats.end();
    }
    render();

    // ------------------------------------------------------------
    // resize
    // ------------------------------------------------------------
    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;

      camera.aspect = w / h;
      camera.updateProjectionMatrix();

      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

      baseComposer.setSize(w, h);
      dot.composer.setSize(w, h);
      copy.composer.setSize(w, h);
      bloom.composer.setSize(w, h);
      film.composer.setSize(w, h);
    });

    // ------------------------------------------------------------
    // Earth mesh
    // ------------------------------------------------------------
    function createEarthSphere() {
      const geom = new THREE.SphereGeometry(10, 40, 40);
      const loader = new THREE.TextureLoader();

      const planetTexture = loader.load(
        "../assets/textures/planets/Earth.png",
        () => (texStatus.planet = "loaded"),
        undefined,
        (e) => { texStatus.planet = "error"; console.error("[Texture] Earth.png load error", e); }
      );
      const specularTexture = loader.load(
        "../assets/textures/planets/EarthSpec.png",
        () => (texStatus.specular = "loaded"),
        undefined,
        (e) => { texStatus.specular = "error"; console.error("[Texture] EarthSpec.png load error", e); }
      );
      const normalTexture = loader.load(
        "../assets/textures/planets/EarthNormal.png",
        () => (texStatus.normal = "loaded"),
        undefined,
        (e) => { texStatus.normal = "error"; console.error("[Texture] EarthNormal.png load error", e); }
      );

      if ("colorSpace" in planetTexture) planetTexture.colorSpace = THREE.SRGBColorSpace;

      const mat = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        map: planetTexture,
        normalMap: normalTexture,
        specularMap: specularTexture,
        specular: new THREE.Color(0x4444aa),
      });

      return new THREE.Mesh(geom, mat);
    }
  </script>
</body>
</html>