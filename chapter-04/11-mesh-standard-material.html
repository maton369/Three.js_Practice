<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Example 04.11 - MeshStandardMaterial (ES Modules + detailed comments)</title>

  <!--
    【このサンプルの狙い】
    - MeshStandardMaterial（PBR: Physically Based Rendering）を GUI で操作し、
      roughness / metalness が見た目にどう影響するかを観察する。
    - 旧サンプルは MeshPhongMaterial の延長のノリで書かれている箇所があり、
      現行three.jsでは非推奨/廃止になったAPI（material.shading 等）や、
      StandardMaterialなのに環境反射（IBL）が無くて「金属っぽさが分かりづらい」などの問題が出やすい。

    【修正方針（現行three.jsに寄せる）】
    - ES Modules + importmap で three を import（window.THREE 前提の古い構成を卒業）
    - dat.GUI → lil-gui、stats.js → stats.module.js
    - material.shading (Flat/Smooth) は廃止 → material.flatShading を使う
    - StandardMaterialは「環境光（IBL）や環境反射」が無いと金属感が出にくいので、
      簡易的に環境マップをPMREM化して scene.environment に設定する（重要）
    - 影は受け/落としをきちんと設定（床 receiveShadow / メッシュ castShadow）
    - colorSpace / toneMapping を設定し、色や明るさが破綻しにくい状態にする
  -->

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>

<body>
  <div id="Stats-output"></div>
  <div id="WebGL-output"></div>

  <script type="module">
    import * as THREE from "three";
    import Stats from "three/addons/libs/stats.module.js";
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

    // ============================================================
    // グローバル（render / resize で参照）
    // ============================================================
    let scene, camera, renderer, stats;
    let groundMesh, mesh;
    let material;
    let pmremGenerator;

    let step = 0;

    // ============================================================
    // init
    // ============================================================
    function init() {
      // ----------------------------------------------------------
      // Stats（FPS表示）
      // ----------------------------------------------------------
      stats = initStats();

      // ----------------------------------------------------------
      // Scene
      // ----------------------------------------------------------
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xeeeeee);

      // ----------------------------------------------------------
      // Camera
      // ----------------------------------------------------------
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(-20, 30, 40);
      camera.lookAt(10, 0, 0);

      // ----------------------------------------------------------
      // Renderer
      // ----------------------------------------------------------
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // 色空間：物理ベース/テクスチャ/色の扱いをまともにするため必須級
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      // トーンマッピング：PBRはHDR的な値を扱うので、見た目の安定に寄与
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      // 影
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      document.getElementById("WebGL-output").appendChild(renderer.domElement);

      // ----------------------------------------------------------
      // Environment（IBL: Image Based Lighting）
      // MeshStandardMaterialの「金属っぽさ」「反射っぽさ」は
      // scene.environment（環境マップ）に強く依存する。
      //
      // - metalness を上げるほど “拡散反射（ベース色）” が減り、
      //   “環境反射” の寄与が増える。
      // - 環境が無いと、金属が「ただ暗いだけ」「ベタ塗り」になりがち。
      //
      // ここでは外部HDRを読み込まずに、three/examples の RoomEnvironment を使って
      // “それっぽい” 環境光/反射を作る（教材用途で便利）。
      // ----------------------------------------------------------
      pmremGenerator = new THREE.PMREMGenerator(renderer);
      const envRT = pmremGenerator.fromScene(new RoomEnvironment(), 0.04);
      scene.environment = envRT.texture;

      // ----------------------------------------------------------
      // Ground（床）
      // 旧コードは MeshBasicMaterial でライト無視だったが、
      // PBR教材としては床もライトが効いた方が分かりやすいので Standard にする。
      // ----------------------------------------------------------
      const groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x555555,
        roughness: 0.9,
        metalness: 0.0
      });

      groundMesh = new THREE.Mesh(groundGeom, groundMat);
      groundMesh.rotation.x = -Math.PI / 2;
      groundMesh.position.y = -20;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      // ----------------------------------------------------------
      // Geometry（トーラスノット）
      // 旧: new THREE.TorusKnotGeometry(10, 3, 200, 20)
      // - 形状のうねり + 面の方向が変わるので、roughness/metalness の違いが分かりやすい。
      // ----------------------------------------------------------
      const geometry = new THREE.TorusKnotGeometry(10, 3, 200, 20);

      // ----------------------------------------------------------
      // MeshStandardMaterial（本題）
      //
      // roughness:
      // - 0 に近いほどツルツル → 反射がシャープ（ハイライト/映り込みが鋭い）
      // - 1 に近いほどザラザラ → 反射がぼやける（マット）
      //
      // metalness:
      // - 0: 非金属（プラスチック/木/石のイメージ）
      //      ベース色(color)が拡散反射として出やすい
      // - 1: 金属
      //      ベース色が反射成分に寄り、環境の映り込みが見えやすい
      // ----------------------------------------------------------
      material = new THREE.MeshStandardMaterial({
        color: 0x7777ff,
        roughness: 0.4,
        metalness: 0.2
      });

      mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(0, 3, 2);
      mesh.castShadow = true;
      mesh.receiveShadow = false;
      scene.add(mesh);

      // ----------------------------------------------------------
      // Lights
      // StandardMaterialは IBL + 直接光（Directional/Spot）で「見え」が決まる。
      // IBLだけでも見えるが、教材としては Key light を当てた方が変化が分かりやすい。
      // ----------------------------------------------------------

      // (1) Ambient：暗部が完全に潰れない保険
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
      scene.add(ambientLight);

      // (2) Directional：安定した主光源（影も分かりやすい）
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
      dirLight.position.set(30, 50, 40);
      dirLight.target.position.set(0, 0, 0);
      dirLight.castShadow = true;

      // 影カメラ（範囲が広すぎると影が粗くなる）
      dirLight.shadow.camera.near = 1;
      dirLight.shadow.camera.far = 200;
      dirLight.shadow.camera.left = -60;
      dirLight.shadow.camera.right = 60;
      dirLight.shadow.camera.top = 60;
      dirLight.shadow.camera.bottom = -60;

      dirLight.shadow.mapSize.set(2048, 2048);
      dirLight.shadow.bias = -0.00005;
      dirLight.shadow.normalBias = 0.02;

      scene.add(dirLight);
      scene.add(dirLight.target);

      // ----------------------------------------------------------
      // GUI（lil-gui）
      // 旧コードの controls を「現行APIに合う形」で整理。
      // - material.overdraw は昔の CanvasRenderer 寄りの概念で今は基本使わないので削除
      // - material.shading は廃止 → material.flatShading に置換
      // ----------------------------------------------------------
      const controls = {
        rotationSpeed: 0.02,

        // material params
        color: material.color.getStyle(),
        roughness: material.roughness,
        metalness: material.metalness,

        visible: material.visible,
        transparent: material.transparent,
        opacity: material.opacity,

        side: "front",
        shading: "smooth", // UI上は flat/smooth として残す（内部は flatShading）

        // renderer params（PBRは露出で見えが変わるので付けると学びが増える）
        exposure: renderer.toneMappingExposure
      };

      const gui = new GUI({ title: "Controls" });

      const fMat = gui.addFolder("MeshStandardMaterial");
      fMat.addColor(controls, "color").onChange((v) => {
        material.color.setStyle(v);
      });
      fMat.add(controls, "roughness", 0, 1, 0.001).onChange((v) => {
        material.roughness = v;
      });
      fMat.add(controls, "metalness", 0, 1, 0.001).onChange((v) => {
        material.metalness = v;
      });

      fMat.add(controls, "visible").onChange((v) => {
        material.visible = v;
      });
      fMat.add(controls, "transparent").onChange((v) => {
        material.transparent = v;
        material.needsUpdate = true;
      });
      fMat.add(controls, "opacity", 0, 1, 0.01).onChange((v) => {
        material.opacity = v;
        // opacity を触ったのに透明にならない事故を防ぐ
        if (v < 1.0 && !material.transparent) {
          material.transparent = true;
          controls.transparent = true;
          material.needsUpdate = true;
        }
      });

      fMat.add(controls, "side", ["front", "back", "double"]).onChange((v) => {
        switch (v) {
          case "front":  material.side = THREE.FrontSide;  break;
          case "back":   material.side = THREE.BackSide;   break;
          case "double": material.side = THREE.DoubleSide; break;
        }
        material.needsUpdate = true;
      });

      fMat.add(controls, "shading", ["flat", "smooth"]).onChange((v) => {
        // 旧: material.shading = Flat/Smooth（廃止）
        // 新: material.flatShading = true/false
        material.flatShading = (v === "flat");

        // flatShading を切り替えると法線の扱いが変わるため、
        // 法線の再計算 + シェーダ再コンパイルが必要になることがある。
        mesh.geometry.computeVertexNormals();
        material.needsUpdate = true;
      });

      const fRen = gui.addFolder("Renderer");
      fRen.add(controls, "exposure", 0.1, 3.0, 0.01).onChange((v) => {
        renderer.toneMappingExposure = v;
      });

      const fScene = gui.addFolder("Scene");
      fScene.add(controls, "rotationSpeed", 0, 0.2, 0.001);

      // ----------------------------------------------------------
      // Resize
      // ----------------------------------------------------------
      window.addEventListener("resize", onResize);

      // ----------------------------------------------------------
      // Render loop
      // ----------------------------------------------------------
      render(controls);
    }

    // ============================================================
    // render
    // ============================================================
    function render(controls) {
      stats.update();

      step += controls.rotationSpeed;
      mesh.rotation.y = step;

      requestAnimationFrame(() => render(controls));
      renderer.render(scene, camera);
    }

    // ============================================================
    // resize
    // ============================================================
    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    // ============================================================
    // stats
    // ============================================================
    function initStats() {
      const s = new Stats();
      s.showPanel(0);
      s.dom.style.position = "absolute";
      s.dom.style.left = "0px";
      s.dom.style.top = "0px";
      document.getElementById("Stats-output").appendChild(s.dom);
      return s;
    }

    // ------------------------------------------------------------
    // ページを離れるときにGPUリソースを解放（教材として“丁寧な後片付け”）
    // ------------------------------------------------------------
    window.addEventListener("beforeunload", () => {
      if (pmremGenerator) pmremGenerator.dispose();
      if (renderer) renderer.dispose();
    });

    window.onload = init;
  </script>
</body>
</html>