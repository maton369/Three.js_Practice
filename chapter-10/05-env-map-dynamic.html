<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>10.05 dynamic envmap（libsなし・ES Modules版 / バグ修正版）</title>

  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }

    /* dat.gui の代わりに素のHTMLで最小UI */
    #ui {
      position: fixed;
      top: 12px; left: 12px;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.92);
      font: 13px/1.3 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
      user-select: none;
    }
    #ui .row { display: grid; grid-template-columns: 120px 1fr; gap: 10px; align-items: center; margin: 8px 0; }
    #ui input[type="range"] { width: 180px; }
    #ui .hint { color: #444; font-size: 12px; margin-top: 8px; max-width: 360px; }
  </style>
</head>

<body>
  <div id="ui">
    <div style="font-weight:700;margin-bottom:8px;">Dynamic EnvMap</div>

    <div class="row">
      <label for="rot">rotationSpeed</label>
      <input id="rot" type="range" min="-0.1" max="0.1" step="0.001" value="0.005" />
    </div>

    <div class="row">
      <label for="scale">sphereScale</label>
      <input id="scale" type="range" min="0.2" max="3.0" step="0.01" value="1.0" />
    </div>

    <div class="hint">
      左ドラッグ：Orbit（回転） / ホイール：ズーム / 右ドラッグ：パン<br>
      ※ 動的envMapは「毎フレーム6回レンダリング」なので重い。解像度は WebGLCubeRenderTarget のサイズで調整する。
    </div>
  </div>

  <script type="module">
    /*
      ============================================================
      バグ原因（あなたのエラーの本質）
      ============================================================

      THREE.Material: parameter 'envMap' has value of undefined.
      CubeCamera.update ... generateMipmaps を読めない

      原因：
        three.js r158 以降の CubeCamera のコンストラクタは

          new THREE.CubeCamera( near, far, renderTarget )

        であり、第三引数は “解像度(数値)” ではなく
        “WebGLCubeRenderTarget” オブジェクトである。

        つまり、
          new THREE.CubeCamera(0.1, 20000, 256)
        は renderTarget に「数値256」を入れてしまい、
        cubeCamera.renderTarget.texture が undefined になって落ちる。

      修正：
        1) WebGLCubeRenderTarget を作る
           const cubeRT = new THREE.WebGLCubeRenderTarget(256, {...});
        2) CubeCamera にそれを渡す
           const cubeCamera = new THREE.CubeCamera(0.1, 20000, cubeRT);
        3) 動的反射の envMap は cubeRT.texture を使う
           material.envMap = cubeRT.texture;

      ============================================================
      全体アルゴリズム（このサンプルのコア）
      ============================================================

      1) 静的環境（Cubemap）をロードし、scene.background に設定（= skybox）
      2) WebGLCubeRenderTarget を用意（= 動的環境マップの“バッファ”）
      3) CubeCamera を用意（= 6方向レンダリングして上のバッファへ書く）
      4) sphere の material.envMap に「バッファのtexture」を入れる（動的反射）
      5) 毎フレームの順序が重要：
         (a) sphere.visible=false（自己写り込み回避）
         (b) cubeCamera.update(renderer, scene)（6回レンダリングして envMap 更新）
         (c) sphere.visible=true
         (d) renderer.render(scene, camera)

      6) OrbitControls 相当は自前実装（libs禁止のため）
         - 左ドラッグ：theta/phi 更新（回転）
         - ホイール：distance 更新（ズーム）
         - 右ドラッグ：target を移動（パン）
    */

    import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";

    // ------------------------------------------------------------
    // UI（dat.gui 代替）
    // ------------------------------------------------------------
    const uiRot = document.getElementById("rot");
    const uiScale = document.getElementById("scale");

    const control = {
      rotationSpeed: parseFloat(uiRot.value),
      scale: parseFloat(uiScale.value),
    };

    uiRot.addEventListener("input", () => {
      control.rotationSpeed = parseFloat(uiRot.value);
    });

    // sphere は後で生成するので、ハンドラ内では存在チェック
    let sphere = null;
    uiScale.addEventListener("input", () => {
      control.scale = parseFloat(uiScale.value);
      if (sphere) sphere.scale.setScalar(control.scale);
    });

    // ------------------------------------------------------------
    // Renderer / Scene / Camera
    // ------------------------------------------------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    document.body.appendChild(renderer.domElement);

    // sRGB（見た目の破綻を減らす）
    if ("outputColorSpace" in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
    else if ("outputEncoding" in renderer) renderer.outputEncoding = THREE.sRGBEncoding;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      10000
    );

    // ------------------------------------------------------------
    // 1) 静的環境（Cubemap）をロード → 背景(=skybox)に使う
    // ------------------------------------------------------------
    const envCube = createCubeMap();
    scene.background = envCube;

    // ------------------------------------------------------------
    // 2) 動的envMap用の “バッファ” を作る（ここが今回の修正点）
    //
    // WebGLCubeRenderTarget:
    //   - size: 1面あたりの解像度
    //   - generateMipmaps: envMap が拡縮されるときのチラつき軽減に有効
    //   - minFilter: Mipmap を使うフィルタ（generateMipmaps=trueとセットが基本）
    // ------------------------------------------------------------
    const cubeRT = new THREE.WebGLCubeRenderTarget(256, {
      format: THREE.RGBAFormat,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter,
    });

    // texture の色空間（環境によっては不要だが、暗すぎ/白すぎを減らす）
    if ("colorSpace" in cubeRT.texture) cubeRT.texture.colorSpace = THREE.SRGBColorSpace;
    else if ("encoding" in cubeRT.texture) cubeRT.texture.encoding = THREE.sRGBEncoding;

    // 3) CubeCamera は “renderTargetを第三引数で受け取る”
    const cubeCamera = new THREE.CubeCamera(0.1, 20000, cubeRT);
    scene.add(cubeCamera);

    // ------------------------------------------------------------
    // ジオメトリとマテリアル
    // ------------------------------------------------------------
    const sphereGeometry   = new THREE.SphereGeometry(4, 32, 32);
    const boxGeometry      = new THREE.BoxGeometry(5, 5, 5);
    const cylinderGeometry = new THREE.CylinderGeometry(2, 4, 10, 24, 1, false);

    // 静的envMap：背景 cubemap をそのまま反射に使う
    const staticEnvMaterial = new THREE.MeshBasicMaterial({
      envMap: envCube,
      side: THREE.DoubleSide,
    });

    // 動的envMap：cubeRT.texture（= CubeCameraが毎フレーム書き込むキューブテクスチャ）
    const dynamicEnvMaterial = new THREE.MeshBasicMaterial({
      envMap: cubeRT.texture,
      side: THREE.DoubleSide,
    });

    // 実体生成
    sphere = new THREE.Mesh(sphereGeometry, dynamicEnvMaterial);
    sphere.name = "sphere";
    sphere.scale.setScalar(control.scale);
    scene.add(sphere);

    const cylinder = new THREE.Mesh(cylinderGeometry, staticEnvMaterial);
    cylinder.name = "cylinder";
    cylinder.position.set(10, 0, 0);
    scene.add(cylinder);

    const cube = new THREE.Mesh(boxGeometry, staticEnvMaterial);
    cube.name = "cube";
    cube.position.set(-10, 0, 0);
    scene.add(cube);

    // ------------------------------------------------------------
    // ライト（MeshBasicMaterial なので見た目は変わらないが将来用の下地）
    // ------------------------------------------------------------
    scene.add(new THREE.AmbientLight(0xffffff, 0.2));
    const pointLight = new THREE.PointLight(0xffffff, 1.0);
    if ("decay" in pointLight) pointLight.decay = 0; // あなたの方針
    pointLight.position.set(0, 10, 10);
    scene.add(pointLight);

    // ------------------------------------------------------------
    // カメラ初期配置 + 自前OrbitControls
    // ------------------------------------------------------------
    camera.position.set(0, 5, 33);
    camera.lookAt(0, 0, 0);

    const orbit = {
      target: new THREE.Vector3(0, 0, 0),
      theta: 0.0,
      phi: 0.25,
      distance: 33.0,
      rotateSpeed: 0.005,
      zoomSpeed: 0.002,
      panSpeed: 0.002,
      dragging: false,
      button: 0,
      lastX: 0,
      lastY: 0,
    };

    syncOrbitFromCamera();

    renderer.domElement.addEventListener("contextmenu", (e) => e.preventDefault());

    renderer.domElement.addEventListener("pointerdown", (e) => {
      orbit.dragging = true;
      orbit.button = e.button; // 0: left, 2: right
      orbit.lastX = e.clientX;
      orbit.lastY = e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
    });

    renderer.domElement.addEventListener("pointerup", (e) => {
      orbit.dragging = false;
      renderer.domElement.releasePointerCapture(e.pointerId);
    });

    renderer.domElement.addEventListener("pointermove", (e) => {
      if (!orbit.dragging) return;

      const dx = e.clientX - orbit.lastX;
      const dy = e.clientY - orbit.lastY;
      orbit.lastX = e.clientX;
      orbit.lastY = e.clientY;

      if (orbit.button === 0) {
        // 左ドラッグ：回転
        orbit.theta -= dx * orbit.rotateSpeed;
        orbit.phi   -= dy * orbit.rotateSpeed;

        // phi の暴走（上下反転）防止
        const eps = 0.001;
        orbit.phi = Math.max(eps, Math.min(Math.PI - eps, orbit.phi));
      } else if (orbit.button === 2) {
        // 右ドラッグ：パン（ターゲット移動）
        const panX = -dx * orbit.panSpeed * (orbit.distance / 10);
        const panY =  dy * orbit.panSpeed * (orbit.distance / 10);

        // カメラの右方向・上方向ベクトルを作って target を動かす
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);

        const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
        const up    = new THREE.Vector3().crossVectors(right, forward).normalize();

        orbit.target.addScaledVector(right, panX);
        orbit.target.addScaledVector(up, panY);
      }
    });

    renderer.domElement.addEventListener("wheel", (e) => {
      orbit.distance *= (1 + e.deltaY * orbit.zoomSpeed);
      orbit.distance = Math.max(2.0, Math.min(5000.0, orbit.distance));
    }, { passive: true });

    // ------------------------------------------------------------
    // render loop（動的envMap更新 → 本描画）
    // ------------------------------------------------------------
    function render() {
      updateOrbitCamera();

      // 重要：動的envMap更新の直前に sphere を隠す（自己写り込み回避）
      sphere.visible = false;

      // CubeCamera は “球の位置” で撮影するのが自然
      cubeCamera.position.copy(sphere.position);

      // ここで 6回レンダリングされ、cubeRT.texture が更新される
      cubeCamera.update(renderer, scene);

      // 戻す
      sphere.visible = true;

      // 本描画
      renderer.render(scene, camera);

      // おまけ：動きを付けて反射変化を分かりやすくする
      cube.rotation.x += control.rotationSpeed;
      cube.rotation.y += control.rotationSpeed;
      cylinder.rotation.x += control.rotationSpeed;

      requestAnimationFrame(render);
    }

    render();

    // ------------------------------------------------------------
    // resize
    // ------------------------------------------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    });

    // ============================================================
    // 補助関数
    // ============================================================

    function createCubeMap() {
      const path = "../assets/textures/cubemap/parliament/";
      const format = ".jpg";
      const urls = [
        path + "posx" + format, path + "negx" + format,
        path + "posy" + format, path + "negy" + format,
        path + "posz" + format, path + "negz" + format
      ];

      const cube = new THREE.CubeTextureLoader().load(urls);

      // 画像は通常 sRGB として扱う
      if ("colorSpace" in cube) cube.colorSpace = THREE.SRGBColorSpace;
      else if ("encoding" in cube) cube.encoding = THREE.sRGBEncoding;

      cube.mapping = THREE.CubeReflectionMapping;
      return cube;
    }

    function syncOrbitFromCamera() {
      const v = camera.position.clone().sub(orbit.target);
      orbit.distance = v.length();
      orbit.theta = Math.atan2(v.x, v.z);
      orbit.phi = Math.acos(THREE.MathUtils.clamp(v.y / orbit.distance, -1, 1));
    }

    function updateOrbitCamera() {
      const sinPhi = Math.sin(orbit.phi);
      const x = orbit.distance * sinPhi * Math.sin(orbit.theta);
      const y = orbit.distance * Math.cos(orbit.phi);
      const z = orbit.distance * sinPhi * Math.cos(orbit.theta);

      camera.position.set(
        orbit.target.x + x,
        orbit.target.y + y,
        orbit.target.z + z
      );

      camera.lookAt(orbit.target);
    }
  </script>
</body>
</html>