<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Example 10.02 - Bump maps（legacy / 修正版）</title>

  <!--
    目的：
      - bumpMap（バンプマップ）で「凹凸っぽさ」を疑似的に表現する流れを理解する。
      - 同じテクスチャでも、bumpMap の有無・bumpScale の強さで見え方が変わることを比較する。

    全体アルゴリズム（このサンプルのコア）：
      1) Scene / Camera / Renderer を初期化
      2) 比較用に “同じ形状” の Mesh を2枚作る
         - 右：通常の map のみ（フラット）
         - 左：map + bumpMap（凹凸風）
      3) 床を置いて陰影やスケール感の手がかりを作る
      4) ライト（Ambient + Spot）で陰影を作る（Phongはライト必須）
      5) dat.GUI で bumpScale / テクスチャ切替 / 回転 の操作を提供
      6) requestAnimationFrame で render loop を回す
         - Stats 更新
         - rotate が true のとき回転
         - renderer.render(scene, camera)

    重要メモ：bumpMap とは？
      - bumpMap は「法線（見かけの表面方向）を擬似的にズラす」ことで凹凸に“見せる”手法である。
      - 実際に頂点が持ち上がる（形状が変わる）わけではない。
      - なので “輪郭（シルエット）” は変わらないが、陰影が変化して立体感が出る。

    元コードの主な問題点（修正点）：
      - TextureLoader を複数箇所で new していて、テクスチャ切替時に管理が散っている
        → loader を1つに集約し、更新関数で map / bumpMap をまとめて差し替える
      - controls.changeTexture が “文字列プロパティ” と “関数” で同名になって上書きされている
        → changeTextureName / applyTextureSet のように命名を分離
      - bumpScale を変えても “material.needsUpdate” を意識していない
        → map/bumpMap の差し替え時に needsUpdate を立てて反映を確実化（古いthree.js対策）
      - plane の Geometry が BoxGeometry で分かりにくい（床なのに箱）
        → PlaneGeometry を使い、意図を明確化（ただし legacy 互換で無い環境があれば戻せる）
      - resize 対応が無い
        → camera / renderer を追従させる
  -->

  <script type="text/javascript" src="../libs/three.js"></script>
  <script type="text/javascript" src="../libs/stats.js"></script>
  <script type="text/javascript" src="../libs/dat.gui.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background: #eee; }
  </style>
</head>

<body>
  <div id="Stats-output"></div>
  <div id="WebGL-output"></div>

  <script type="text/javascript">
    function init() {
      // ------------------------------------------------------------
      // Stats（FPS表示）
      // ------------------------------------------------------------
      var stats = initStats();

      // ------------------------------------------------------------
      // Scene / Camera / Renderer（描画の土台）
      // ------------------------------------------------------------
      var scene = new THREE.Scene();

      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      var renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor(new THREE.Color(0xEEEEEE));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;

      document.getElementById("WebGL-output").appendChild(renderer.domElement);

      // ------------------------------------------------------------
      // カメラ配置：比較対象が左右に並ぶので、少し引いて中央を見る
      // ------------------------------------------------------------
      camera.position.set(0, 12, 28);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // ------------------------------------------------------------
      // ライト：Phong なので “陰影” を作るライトが必要
      // ------------------------------------------------------------
      var ambiLight = new THREE.AmbientLight(0x242424);
      scene.add(ambiLight);

      var light = new THREE.SpotLight(0xffffff, 1.2);
      light.position.set(0, 30, 30);
      // 影を本気で使うなら castShadow/receiveShadow を揃えるが、
      // 今回のテーマは bumpMap なので最低限にしている
      scene.add(light);

      // ------------------------------------------------------------
      // TextureLoader を1つに集約（管理が散ると切替が壊れやすい）
      // ------------------------------------------------------------
      var textureLoader = new THREE.TextureLoader();

      // ------------------------------------------------------------
      // 比較用の板（左右に2枚）
      //  - 右：map のみ
      //  - 左：map + bumpMap
      // geometry は “板” なので BoxGeometry(薄い箱)でも良いが、
      // 意図が明確な PlaneGeometry を使う（環境差がある場合は BoxGeometry に戻す）
      // ------------------------------------------------------------
      var geom = new THREE.PlaneGeometry(15, 15, 1, 1);

      // 右：通常（フラット）
      var flatMesh = createMeshWithPhong(geom, "stone.jpg", null, 0.0);
      flatMesh.rotation.y = -0.5;
      flatMesh.position.x = 12;
      scene.add(flatMesh);

      // 左：bump あり（凹凸風）
      var bumpMesh = createMeshWithPhong(geom, "stone.jpg", "stone-bump.jpg", 0.2);
      bumpMesh.rotation.y = 0.5;
      bumpMesh.position.x = -12;
      scene.add(bumpMesh);

      // ------------------------------------------------------------
      // 床：陰影の変化や距離感が分かりやすくなる
      // ------------------------------------------------------------
      var floorTex = textureLoader.load("../assets/textures/general/floor-wood.jpg");

      // テクスチャの見え方調整（床が引き伸ばされるのを軽減）
      floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
      floorTex.repeat.set(4, 2);

      var floorMat = new THREE.MeshPhongMaterial({
        color: 0x3c3c3c,
        map: floorTex
      });

      var floorGeom = new THREE.PlaneGeometry(200, 100, 1, 1);
      var floor = new THREE.Mesh(floorGeom, floorMat);
      floor.position.y = -7.5;
      floor.rotation.x = -0.5 * Math.PI;
      scene.add(floor);

      // ------------------------------------------------------------
      // GUI：bumpScale / テクスチャ切替 / 回転
      //
      // “同名プロパティと関数で上書き” を避けるため命名を分ける
      // ------------------------------------------------------------
      var controls = new (function () {
        // bump の強さ（見かけの凹凸量）
        this.bumpScale = 0.2;

        // 現在のテクスチャセット名（general/<name>.jpg と general/<name>-bump.jpg を想定）
        this.textureSet = "weave";

        // 回転デモ
        this.rotate = false;

        // テクスチャセットを適用（map / bumpMap をまとめて差し替える）
        this.applyTextureSet = function (name) {
          // map（色）
          var mapTex = textureLoader.load("../assets/textures/general/" + name + ".jpg");
          // bump（凹凸）
          var bumpTex = textureLoader.load("../assets/textures/general/" + name + "-bump.jpg");

          // 右（フラット）は map だけ差し替え
          flatMesh.material.map = mapTex;

          // 左（バンプ）は map + bumpMap を差し替え
          bumpMesh.material.map = mapTex;
          bumpMesh.material.bumpMap = bumpTex;

          // 古い three.js では差し替え後に needsUpdate が必要なことがある
          flatMesh.material.needsUpdate = true;
          bumpMesh.material.needsUpdate = true;
        };

        // bumpScale を適用
        this.applyBumpScale = function (v) {
          bumpMesh.material.bumpScale = v;
          bumpMesh.material.needsUpdate = true;
        };
      })();

      var gui = new dat.GUI();
      gui.add(controls, "bumpScale", -2, 2).onChange(function (v) { controls.applyBumpScale(v); });
      gui.add(controls, "textureSet", ["stone", "weave"]).onChange(function (name) { controls.applyTextureSet(name); });
      gui.add(controls, "rotate");

      // 初期値：GUI に合わせて bumpScale を反映
      controls.applyBumpScale(controls.bumpScale);

      // ------------------------------------------------------------
      // 描画ループ：bumpMap の効果を見比べられるように回転を用意
      // ------------------------------------------------------------
      function render() {
        stats.update();

        if (controls.rotate) {
          flatMesh.rotation.y -= 0.01;
          bumpMesh.rotation.y += 0.01;
        }

        requestAnimationFrame(render);
        renderer.render(scene, camera);
      }

      // ------------------------------------------------------------
      // resize 対応：アスペクトとレンダラサイズを追従
      // ------------------------------------------------------------
      window.addEventListener("resize", function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      render();

      // ------------------------------------------------------------
      // mesh生成：Phong + map + optional bump
      // ------------------------------------------------------------
      function createMeshWithPhong(geom, imageFile, bumpFile, bumpScale) {
        // map（色）
        var texture = textureLoader.load("../assets/textures/general/" + imageFile);

        // “陰影” を綺麗にするため、法線を計算（PlaneGeometryなら基本不要だが、legacy対策で安全）
        if (geom && typeof geom.computeVertexNormals === "function") {
          geom.computeVertexNormals();
        }

        var mat = new THREE.MeshPhongMaterial();
        mat.map = texture;

        // bump（凹凸）
        if (bumpFile) {
          var bump = textureLoader.load("../assets/textures/general/" + bumpFile);
          mat.bumpMap = bump;
          mat.bumpScale = bumpScale;
        }

        return new THREE.Mesh(geom, mat);
      }

      // ------------------------------------------------------------
      // Stats 初期化
      // ------------------------------------------------------------
      function initStats() {
        var stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        stats.domElement.style.position = "absolute";
        stats.domElement.style.left = "0px";
        stats.domElement.style.top = "0px";
        document.getElementById("Stats-output").appendChild(stats.domElement);

        return stats;
      }
    }

    window.onload = init;
  </script>
</body>
</html>