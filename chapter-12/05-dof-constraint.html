<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Physijs Constraints - Car (DOFConstraint) / 詳細コメント付き</title>

  <style>
    /* フルスクリーン表示（Physijs/three のデモでは定番） */
    body { margin: 0; overflow: hidden; background: #000; }
    #viewport { width: 100vw; height: 100vh; }
    canvas { display: block; }
  </style>

  <!--
    ============================================================
    依存ライブラリ（../libs を使う前提の Physijs 版）
    ============================================================
    - three.js     : 描画
    - physi.js     : three の Mesh と Ammo.js 物理を橋渡しするラッパ
    - physijs_worker.js : 物理計算を別スレッド（WebWorker）で動かす
    - ammo.js      : 物理エンジン（Bullet の JS 移植）
    - stats.js     : FPS 表示
    - dat.gui.js   : パラメータ操作 UI

    ※ chroma.js はこのサンプルでは色スケールを作っているが、
      今回の「車」サンプルでは未使用なので残しつつコメントで明示する。
  -->
  <script src="../libs/three.js"></script>
  <script src="../libs/stats.js"></script>
  <script src="../libs/physi.js"></script>
  <script src="../libs/dat.gui.js"></script>
  <script src="../libs/chroma.js"></script>

  <script>
    'use strict';

    // ============================================================
    // 0) Physijs のワーカー / ammo のパス設定（最重要）
    // ============================================================
    // Physijs は内部で Worker を使って Ammo を走らせる。
    // ここが間違っていると「真っ黒」「物理が動かない」「CORS」など色々起きる。
    Physijs.scripts.worker = '../libs/physijs_worker.js';
    Physijs.scripts.ammo   = '../libs/ammo.js';

    // chroma のスケール（このファイルでは未使用：残しても動作はする）
    var scale = chroma.scale(['white', 'blue', 'red', 'yellow']);

    // ============================================================
    // 1) グローバル（サンプルなのでグローバル管理）
    // ============================================================
    var renderer, scene, camera, light;
    var render_stats;

    var ground_material, ground;
    var car; // { body, wheels, constraints... } をまとめたオブジェクト

    // Physijs を使うと「scene.simulate(...)」が物理ステップの入口になる
    var render = function () {};

    // ============================================================
    // 2) 初期化（エントリポイント）
    // ============================================================
    function initScene() {
      // ----------------------------
      // (A) three.js renderer
      // ----------------------------
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(new THREE.Color(0x000000));
      renderer.shadowMap.enabled = true;

      document.getElementById('viewport').appendChild(renderer.domElement);

      // ----------------------------
      // (B) stats（FPS）
      // ----------------------------
      render_stats = new Stats();
      render_stats.domElement.style.position = 'absolute';
      render_stats.domElement.style.top = '1px';
      render_stats.domElement.style.left = '1px';
      render_stats.domElement.style.zIndex = 100;
      document.getElementById('viewport').appendChild(render_stats.domElement);

      // ----------------------------
      // (C) Physijs Scene（物理世界）
      // ----------------------------
      // reportSize: 物理→描画同期で送ってくるデータの粒度（デバッグ用途）
      // fixedTimeStep: 物理の固定刻み（1/60 が定番）
      scene = new Physijs.Scene({ reportSize: 10, fixedTimeStep: 1 / 60 });

      // 重力（元コードは -40 と強め。車が暴れやすいので、基本は強めでもOKだが
      // 反発/摩擦との兼ね合いで不安定なら -20〜-30 に下げると安定する）
      scene.setGravity(new THREE.Vector3(0, -40, 0));

      // ----------------------------
      // (D) camera
      // ----------------------------
      camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);

      // 【修正ポイント】
      // 元コードは ground を (x=20, z=-20) にずらしているのに、車は (5,5,5) 付近に置いていた。
      // その結果、「車が地面の中心からズレた位置でスタート」し、境界に当たりやすい。
      // → ground の中心に合わせて車の初期位置も寄せる。
      camera.position.set(90, 90, 90);
      camera.lookAt(new THREE.Vector3(20, 0, -20));
      scene.add(camera);

      // ----------------------------
      // (E) light
      // ----------------------------
      light = new THREE.SpotLight(0xFFFFFF);
      light.position.set(120, 70, 100);
      light.castShadow = true;

      // shadow 設定（デモで見やすい程度に）
      light.shadow.camera.near = 10;
      light.shadow.camera.far  = 200;

      // 【修正ポイント】
      // mapSize は 2 の冪が無難（1024/2048）。
      // 元コード 1028 だと環境によっては意図通り最適化されないことがある。
      light.shadow.mapSize.width  = 1024;
      light.shadow.mapSize.height = 1024;

      scene.add(light);

      // ----------------------------
      // (F) ステージ生成
      // ----------------------------
      createGround();
      car = createCar();

      // ----------------------------
      // (G) UI（dat.GUI）
      // ----------------------------
      // ※ Physijs の DOFConstraint のモーター制御を GUI で触れるようにする
      var controls = new function () {
        // forward/backward の目標速度（符号で前進/後退）
        this.velocity = -2;

        // 後輪の「向き（ステア角）」：y軸回りの回転制約をずらして疑似ステアを作る
        this.wheelAngle = 0.5;

        // 後輪の x 軸方向の拘束を少し緩める（完全固定だと暴れることがある）
        // 0 に近いほど「固く」、大きいほど「ふにゃふにゃ」になる
        this.loosenXRight = 0.0;
        this.loosenXLeft  = 0.0;

        // ------------------------------------------------------------
        // 前輪モーター（回転）を更新
        // ------------------------------------------------------------
        this.changeVelocity = function () {
          // DOFConstraint の angular motor は「軸 index（0/1/2）」ごとに設定する。
          // ここでは index=2 を「前進/後退用（ホイール回転）」として使っている。
          //
          // configureAngularMotor(axis, low, high, velocity, maxForce)
          // - low/high : 角速度/回転範囲の制限（実装依存の挙動がある）
          // - velocity : 目標角速度（車輪の回転スピード）
          // - maxForce : モーターが出せる最大トルク（大きいほど強引に回す）
          //
          // 【重要】
          // Physijs では「モーターを構成→enable」で有効化する。
          // configure だけでは回り始めないことがある。
          car.flConstraint.configureAngularMotor(2, 0.1, 0, controls.velocity, 15000);
          car.frConstraint.configureAngularMotor(2, 0.1, 0, controls.velocity, 15000);

          // 前輪の forward/backward motor を有効化
          car.flConstraint.enableAngularMotor(2);
          car.frConstraint.enableAngularMotor(2);
        };

        // ------------------------------------------------------------
        // 後輪の向き（疑似ステア）を更新
        // ------------------------------------------------------------
        this.changeOrientation = function () {
          // 【修正ポイント】
          // Physijs の setAngularLowerLimit / setAngularUpperLimit は
          // THREE.Vector3 を渡すのが安全（例の object {x,y,z} でも動く実装はあるが互換性が落ちる）。
          //
          // ここでは「y（ヨー）」だけ wheelAngle を与え、
          // 他軸は 0 付近に固定（必要なら loosenX* で少し緩める）。
          car.rrConstraint.setAngularLowerLimit(new THREE.Vector3(0, controls.wheelAngle, 0.1));
          car.rrConstraint.setAngularUpperLimit(new THREE.Vector3(controls.loosenXRight, controls.wheelAngle, 0));

          car.rlConstraint.setAngularLowerLimit(new THREE.Vector3(controls.loosenXLeft, controls.wheelAngle, 0.1));
          car.rlConstraint.setAngularUpperLimit(new THREE.Vector3(0, controls.wheelAngle, 0));
        };
      };

      var gui = new dat.GUI();

      gui.add(controls, 'velocity', -10, 10).onChange(controls.changeVelocity);
      gui.add(controls, 'wheelAngle', -1, 1).onChange(controls.changeOrientation);

      // 【修正ポイント】
      // step() は正の値で刻むのが通常。元コードは loosenXLeft に step(-0.01) が入っていた。
      // → 操作性が崩れるので 0.01 に統一。
      gui.add(controls, 'loosenXRight', 0, 0.5).step(0.01).onChange(controls.changeOrientation);
      gui.add(controls, 'loosenXLeft',  0, 0.6).step(0.01).onChange(controls.changeOrientation);

      // 初期反映
      controls.changeOrientation();
      controls.changeVelocity();

      // ----------------------------
      // (H) レンダリング開始
      // ----------------------------
      requestAnimationFrame(render);

      // Physijs は「最初に simulate() を呼ぶ」と Worker が動き始める
      scene.simulate();
    }

    // ============================================================
    // 3) 車の構成要素（Wheel / Car / Constraints）
    // ============================================================

    function createWheel(position) {
      // wheel は「摩擦が高い」ほうが車っぽくなる
      var wheelMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ color: 0x444444, opacity: 0.9, transparent: true }),
        1.0, // friction（高い）
        0.5  // restitution（ほどほど）
      );

      // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)
      var wheelGeometry = new THREE.CylinderGeometry(4, 4, 2, 16);

      // Physijs.CylinderMesh は ammo の CylinderShape を使う（衝突形状が円柱になる）
      var wheel = new Physijs.CylinderMesh(wheelGeometry, wheelMaterial, 100);

      // cylinder はデフォルトでY方向に伸びるので、Xに倒して「タイヤ」に見せる
      wheel.rotation.x = Math.PI / 2;

      wheel.castShadow = true;
      wheel.position.copy(position);
      return wheel;
    }

    function createWheelConstraint(wheel, body, position) {
      // DOFConstraint: 6自由度制約（平行移動3 + 回転3）
      // - 車輪と車体を「ある一点（position）」で接続し、回転自由度を制御できる
      // - Hinge だけだとステアや複数軸の制約が扱いにくいので DOF を使っている
      return new Physijs.DOFConstraint(wheel, body, position);
    }

    function createCar() {
      // car は「車体(body)」「車輪(wheels)」「制約(constraints)」を束ねて返す
      var car = {};

      var carMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ color: 0xff4444, opacity: 0.9, transparent: true }),
        0.5, // friction
        0.5  // restitution
      );

      // ----------------------------
      // 車体（box）
      // ----------------------------
      var bodyGeom = new THREE.BoxGeometry(15, 4, 4);

      // mass=500 でそこそこ重い車体にする（軽いと跳ねやすい）
      var body = new Physijs.BoxMesh(bodyGeom, carMaterial, 500);

      // 【修正ポイント】
      // ground を (20,0,-20) に置いているので、車もその近辺で開始
      body.position.set(20, 5, -20);
      body.castShadow = true;
      scene.add(body);

      // ----------------------------
      // 車輪（4つ）
      // ----------------------------
      // 車体中心 (20,5,-20) を基準に、前後左右へ配置
      // - x: 左右（このデモは x が「車の左右」っぽい）
      // - z: 前後
      var fr = createWheel(new THREE.Vector3(13, 4, -12)); // 前右
      var fl = createWheel(new THREE.Vector3(13, 4, -28)); // 前左
      var rr = createWheel(new THREE.Vector3(27, 4, -12)); // 後右
      var rl = createWheel(new THREE.Vector3(27, 4, -28)); // 後左

      scene.add(fr); scene.add(fl); scene.add(rr); scene.add(rl);

      // ----------------------------
      // 制約（車輪 - 車体）
      // ----------------------------
      // position は「接続点（ワールド座標）」：
      // wheel と body をこの点で繋ぐ。タイヤの中心あたりに置くのが分かりやすい。
      var frConstraint = createWheelConstraint(fr, body, new THREE.Vector3(13, 4, -14));
      var flConstraint = createWheelConstraint(fl, body, new THREE.Vector3(13, 4, -26));
      var rrConstraint = createWheelConstraint(rr, body, new THREE.Vector3(27, 4, -14));
      var rlConstraint = createWheelConstraint(rl, body, new THREE.Vector3(27, 4, -26));

      scene.addConstraint(frConstraint);
      scene.addConstraint(flConstraint);
      scene.addConstraint(rrConstraint);
      scene.addConstraint(rlConstraint);

      // ----------------------------
      // 後輪：向き（ステア）を制限する（疑似ステア）
      // ----------------------------
      // 「lower と upper を同じ値」にすると、その軸は固定に近い挙動になる。
      // ここでは y=0.5 を初期ステア角として与え、x は後で loosen できるようにする。
      rrConstraint.setAngularLowerLimit(new THREE.Vector3(0, 0.5, 0.1));
      rrConstraint.setAngularUpperLimit(new THREE.Vector3(0, 0.5, 0.0));

      rlConstraint.setAngularLowerLimit(new THREE.Vector3(0, 0.5, 0.1));
      rlConstraint.setAngularUpperLimit(new THREE.Vector3(0, 0.5, 0.0));

      // ----------------------------
      // 前輪：モーターで回す（前進/後退）
      // ----------------------------
      // 前輪は「回転自由度」をモーターで上書きするので、
      // ここでは角度制限は一旦 0 に固定しておく（モーターが上書きする想定）
      frConstraint.setAngularLowerLimit(new THREE.Vector3(0, 0, 0));
      frConstraint.setAngularUpperLimit(new THREE.Vector3(0, 0, 0));

      flConstraint.setAngularLowerLimit(new THREE.Vector3(0, 0, 0));
      flConstraint.setAngularUpperLimit(new THREE.Vector3(0, 0, 0));

      // モーター設定：axis=2 を使用
      // - velocity=-2 で回転（進む方向は車輪向き/地面摩擦次第で決まる）
      // - maxForce は強いほど空転せず回そうとする（強すぎると不安定化）
      flConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500);
      frConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500);

      flConstraint.enableAngularMotor(2);
      frConstraint.enableAngularMotor(2);

      // car オブジェクトにまとめて返す（GUI から触るため）
      car.body = body;
      car.fr = fr; car.fl = fl; car.rr = rr; car.rl = rl;
      car.frConstraint = frConstraint;
      car.flConstraint = flConstraint;
      car.rrConstraint = rrConstraint;
      car.rlConstraint = rlConstraint;

      return car;
    }

    // ============================================================
    // 4) Ground（床 + 壁）
    // ============================================================
    function createGround() {
      var length = 120;
      var width  = 120;

      // texture は無くても動くが、あると見栄えが良い
      var textureLoader = new THREE.TextureLoader();

      ground_material = Physijs.createMaterial(
        new THREE.MeshPhongMaterial({
          map: textureLoader.load('../assets/textures/general/floor-wood.jpg')
        }),
        1.0, // friction（高め＝タイヤが滑りにくい）
        0.7  // restitution（そこそこ＝跳ねやすい。暴れるなら 0.2〜0.4 に下げる）
      );

      // 床：mass=0（静的）
      ground = new Physijs.BoxMesh(
        new THREE.BoxGeometry(length, 1, width),
        ground_material,
        0
      );
      ground.receiveShadow = true;

      // 壁：床の子として追加（まとめて移動できる）
      var borderLeft = new Physijs.BoxMesh(
        new THREE.BoxGeometry(2, 6, width),
        ground_material,
        0
      );
      borderLeft.position.x = -length / 2 - 1;
      borderLeft.position.y = 2;
      borderLeft.receiveShadow = true;
      ground.add(borderLeft);

      var borderRight = new Physijs.BoxMesh(
        new THREE.BoxGeometry(2, 6, width),
        ground_material,
        0
      );
      borderRight.position.x = length / 2 + 1;
      borderRight.position.y = 2;
      borderRight.receiveShadow = true;
      ground.add(borderRight);

      var borderBottom = new Physijs.BoxMesh(
        new THREE.BoxGeometry(width - 1, 6, 2),
        ground_material,
        0
      );
      borderBottom.position.z = width / 2;
      borderBottom.position.y = 1.5;
      borderBottom.receiveShadow = true;
      ground.add(borderBottom);

      var borderTop = new Physijs.BoxMesh(
        new THREE.BoxGeometry(width, 6, 2),
        ground_material,
        0
      );
      borderTop.position.z = -width / 2;
      borderTop.position.y = 2;
      borderTop.receiveShadow = true;
      ground.add(borderTop);

      // 【このサンプルの特徴】地面を平行移動している
      // - その場合、車やカメラの lookAt も同じ中心へ寄せると分かりやすい
      ground.position.x = 20;
      ground.position.z = -20;

      scene.add(ground);
    }

    // ============================================================
    // 5) レンダリングループ（物理ステップ + 描画）
    // ============================================================
    render = function () {
      requestAnimationFrame(render);

      // 先に描画
      renderer.render(scene, camera);

      // stats 更新
      render_stats.update();

      // Physijs の物理ステップ
      // simulate(timeStep, maxSubSteps) の引数は実装差分があるが、
      // このサンプルでは (undefined, 2) にして「最大2回サブステップ」を許可している。
      // フレームが落ちたときでも物理が極端に遅れないようにする狙い。
      scene.simulate(undefined, 2);
    };

    // ============================================================
    // 6) リサイズ対応（ないとウィンドウ変更で縦横比が崩れる）
    // ============================================================
    window.addEventListener('resize', function () {
      var w = window.innerWidth;
      var h = window.innerHeight;

      camera.aspect = w / h;
      camera.updateProjectionMatrix();

      renderer.setSize(w, h);
    });

    // 起動
    window.onload = initScene;
  </script>
</head>

<body>
  <div id="viewport"></div>
</body>
</html>