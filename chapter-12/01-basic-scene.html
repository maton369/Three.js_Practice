<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rigid body - Physics（three.js + cannon-es / libsフォルダ不使用 / 詳細コメント）</title>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js"
      }
    }
  </script>

  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #viewport { width: 100vw; height: 100vh; }
    canvas { display: block; }

    .hud {
      position: fixed;
      left: 10px;
      top: 10px;
      z-index: 10;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif;
      background: rgba(0,0,0,0.55);
      padding: 10px 12px;
      border-radius: 10px;
      user-select: none;
      min-width: 280px;
    }
    .hud h1 { margin: 0 0 8px; font-size: 14px; font-weight: 700; }
    .row {
      display: grid;
      grid-template-columns: 72px 1fr 54px;
      gap: 8px;
      align-items: center;
      margin: 6px 0;
      font-size: 12px;
    }
    .row input[type="range"] { width: 100%; }
    .row .val { text-align: right; font-variant-numeric: tabular-nums; opacity: 0.9; }
    .btns { display: flex; gap: 8px; margin-top: 8px; }
    button {
      background: #1f6feb;
      color: #fff;
      border: 0;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
    }
    button:active { transform: translateY(1px); }
    .fps { margin-top: 8px; font-size: 12px; opacity: 0.9; }
  </style>
</head>
<body>
  <div id="viewport"></div>

  <div class="hud">
    <h1>Rigid Body Domino（three + cannon-es）</h1>

    <div class="row">
      <div>gravityX</div>
      <input id="gx" type="range" min="-100" max="100" step="1" value="0">
      <div class="val" id="gxv">0</div>
    </div>
    <div class="row">
      <div>gravityY</div>
      <input id="gy" type="range" min="-100" max="100" step="1" value="-50">
      <div class="val" id="gyv">-50</div>
    </div>
    <div class="row">
      <div>gravityZ</div>
      <input id="gz" type="range" min="-100" max="100" step="1" value="0">
      <div class="val" id="gzv">0</div>
    </div>

    <div class="btns">
      <button id="reset">resetScene</button>
      <button id="pause">pause</button>
    </div>

    <div class="fps" id="fps">FPS: --</div>
  </div>

  <script type="module">
    /*
      ============================================================
      修正内容：Uncaught ReferenceError: points is not defined
      ============================================================

      ■ 原因
      - createDominos() 内で `if (!points) points = getSpiralPoints();` と書いているが、
        `points` という変数自体を宣言していないため ReferenceError になる。
        （未宣言変数は “undefined” ですらなく、参照した瞬間に例外）

      ■ 対応
      - `let points = null;` を “createDominos より前” のスコープに追加し、
        resetScene のたびに再利用できるようにする。

      ※ ついでに
      - points を毎回生成し直す意味は薄いので、最初に生成してキャッシュする方が軽い。
        → 今回は points を “キャッシュ” として扱う実装にする。
      ============================================================
    */

    import * as THREE from "three";
    import * as CANNON from "https://esm.sh/cannon-es@0.20.0";

    // -----------------------------
    // DOM
    // -----------------------------
    const viewport = document.getElementById("viewport");

    const gx = document.getElementById("gx");
    const gy = document.getElementById("gy");
    const gz = document.getElementById("gz");
    const gxv = document.getElementById("gxv");
    const gyv = document.getElementById("gyv");
    const gzv = document.getElementById("gzv");

    const btnReset = document.getElementById("reset");
    const btnPause = document.getElementById("pause");
    const fpsEl = document.getElementById("fps");

    function syncGravityLabels() {
      gxv.textContent = String(gx.value);
      gyv.textContent = String(gy.value);
      gzv.textContent = String(gz.value);
    }
    syncGravityLabels();

    // -----------------------------
    // three.js
    // -----------------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0x000000, 1.0);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.shadowMap.enabled = true;

    if ("outputColorSpace" in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
    else if ("outputEncoding" in renderer) renderer.outputEncoding = THREE.sRGBEncoding;

    viewport.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(50, 30, 50);
    camera.lookAt(10, 0, 10);

    const dir = new THREE.DirectionalLight(0xffffff, 0.35);
    dir.position.set(30, 80, 40);
    scene.add(dir);

    const spot = new THREE.SpotLight(0xffffff, 1.0);
    spot.position.set(20, 100, 50);
    spot.castShadow = true;
    spot.decay = 0;      // ✅ ユーザー方針：SpotLight の decay は 0
    spot.distance = 0;
    spot.angle = Math.PI * 0.25;
    spot.penumbra = 0.25;
    spot.shadow.mapSize.set(2048, 2048);
    spot.shadow.camera.near = 1;
    spot.shadow.camera.far = 250;
    spot.target.position.set(0, 0, 0);
    scene.add(spot);
    scene.add(spot.target);

    // -----------------------------
    // cannon-es
    // -----------------------------
    const world = new CANNON.World({
      gravity: new CANNON.Vec3(0, -50, 0)
    });

    world.broadphase = new CANNON.SAPBroadphase(world);
    world.allowSleep = true;

    const matGround = new CANNON.Material("ground");
    const matStone  = new CANNON.Material("stone");

    const contact = new CANNON.ContactMaterial(matGround, matStone, {
      friction: 0.9,
      restitution: 0.3
    });
    world.defaultContactMaterial.friction = 0.3;
    world.defaultContactMaterial.restitution = 0.0;
    world.addContactMaterial(contact);

    // -----------------------------
    // 同期用データ
    // -----------------------------
    const pairs = [];   // scene描画と物理を同期する対象（床/壁/ドミノなど全部）
    const dominos = []; // resetで作り直す対象（ドミノのみ）

    // ✅ ここが今回の修正の本体：points を宣言してキャッシュする
    let points = null;

    // -----------------------------
    // テクスチャ（床）
    // -----------------------------
    const texLoader = new THREE.TextureLoader();

    let floorTex = null;
    try {
      floorTex = texLoader.load("../assets/textures/general/wood-2.jpg");
      if ("colorSpace" in floorTex) floorTex.colorSpace = THREE.SRGBColorSpace;
      floorTex.wrapS = THREE.RepeatWrapping;
      floorTex.wrapT = THREE.RepeatWrapping;
      floorTex.repeat.set(4, 4);
    } catch (_) {
      floorTex = null;
    }

    // -----------------------------
    // ヘルパ
    // -----------------------------
    function randomGreenWhiteColor() {
      const t = Math.random();
      return new THREE.Color(t, 1, t); // green -> white の簡易補間
    }

    function addStaticBox({ sx, sy, sz, px, py, pz, material, threeMaterial, castShadow = false, receiveShadow = false }) {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(sx * 2, sy * 2, sz * 2),
        threeMaterial
      );
      mesh.position.set(px, py, pz);
      mesh.castShadow = castShadow;
      mesh.receiveShadow = receiveShadow;
      scene.add(mesh);

      const shape = new CANNON.Box(new CANNON.Vec3(sx, sy, sz));
      const body = new CANNON.Body({ mass: 0, material });
      body.addShape(shape);
      body.position.set(px, py, pz);
      world.addBody(body);

      pairs.push({ mesh, body });
      return { mesh, body };
    }

    function addDynamicBox({ sx, sy, sz, px, py, pz, quat, material, threeMaterial, castShadow = true, receiveShadow = false, mass = 1 }) {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(sx * 2, sy * 2, sz * 2),
        threeMaterial
      );
      mesh.position.set(px, py, pz);
      if (quat) mesh.quaternion.copy(quat);
      mesh.castShadow = castShadow;
      mesh.receiveShadow = receiveShadow;
      scene.add(mesh);

      const shape = new CANNON.Box(new CANNON.Vec3(sx, sy, sz));
      const body = new CANNON.Body({ mass, material });
      body.addShape(shape);
      body.position.set(px, py, pz);
      if (quat) body.quaternion.set(quat.x, quat.y, quat.z, quat.w);

      body.allowSleep = true;
      body.sleepTimeLimit = 0.5;
      body.sleepSpeedLimit = 0.2;

      world.addBody(body);

      pairs.push({ mesh, body });
      return { mesh, body };
    }

    function getSpiralPoints() {
      const pts = [];
      const r = 27;
      const cX = 0;
      const cZ = 0;

      let circleOffset = 0;
      for (let i = 0; i < 1000; i += 6 + circleOffset) {
        circleOffset = 4.5 * (i / 360);

        const rad = i * (Math.PI / 180);
        const k = (r / 1440) * (1440 - i);

        const x = k * Math.cos(rad) + cX;
        const z = k * Math.sin(rad) + cZ;

        pts.push(new THREE.Vector3(x, 0, z));
      }
      return pts;
    }

    function createGroundAndBorders() {
      const groundMat3 = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        map: floorTex || null
      });

      addStaticBox({
        sx: 30, sy: 0.5, sz: 30,
        px: 0, py: 0, pz: 0,
        material: matGround,
        threeMaterial: groundMat3,
        receiveShadow: true
      });

      addStaticBox({
        sx: 1, sy: 1.5, sz: 30,
        px: -31, py: 2, pz: 0,
        material: matGround,
        threeMaterial: groundMat3,
        receiveShadow: true
      });

      addStaticBox({
        sx: 1, sy: 1.5, sz: 30,
        px: 31, py: 2, pz: 0,
        material: matGround,
        threeMaterial: groundMat3,
        receiveShadow: true
      });

      addStaticBox({
        sx: 32, sy: 1.5, sz: 1,
        px: 0, py: 2, pz: -30,
        material: matGround,
        threeMaterial: groundMat3,
        receiveShadow: true
      });

      addStaticBox({
        sx: 32, sy: 1.5, sz: 1,
        px: 0, py: 2, pz: 30,
        material: matGround,
        threeMaterial: groundMat3,
        receiveShadow: true
      });
    }

    function clearDominos() {
      for (const d of dominos) {
        scene.remove(d.mesh);
        if (d.mesh.geometry) d.mesh.geometry.dispose();
        if (d.mesh.material) d.mesh.material.dispose();
      }
      for (const d of dominos) {
        world.removeBody(d.body);
      }

      const dominoBodies = new Set(dominos.map(d => d.body));
      for (let i = pairs.length - 1; i >= 0; i--) {
        if (dominoBodies.has(pairs[i].body)) pairs.splice(i, 1);
      }

      dominos.length = 0;
    }

    function createDominos() {
      // ✅ points が未生成なら生成してキャッシュ
      if (points === null) points = getSpiralPoints();

      const sx = 0.3, sy = 3.0, sz = 1.0;

      for (const p of points) {
        const mat3 = new THREE.MeshPhongMaterial({
          color: randomGreenWhiteColor(),
          transparent: true,
          opacity: 0.8
        });

        const tmpObj = new THREE.Object3D();
        tmpObj.position.copy(p);
        tmpObj.position.y = 3.5;
        tmpObj.lookAt(0, 0, 0);
        const quat = tmpObj.quaternion.clone();

        const d = addDynamicBox({
          sx, sy, sz,
          px: tmpObj.position.x,
          py: tmpObj.position.y,
          pz: tmpObj.position.z,
          quat,
          material: matStone,
          threeMaterial: mat3,
          castShadow: true,
          mass: 1
        });

        dominos.push(d);
      }

      // きっかけを作る
      if (dominos.length > 0) {
        const first = dominos[0];

        const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.2, 0, 0, "XYZ"));
        const current = new THREE.Quaternion(
          first.body.quaternion.x,
          first.body.quaternion.y,
          first.body.quaternion.z,
          first.body.quaternion.w
        );
        current.multiply(q);

        first.body.quaternion.set(current.x, current.y, current.z, current.w);
        first.body.angularVelocity.set(0.1, 0, 0);
      }
    }

    function applyGravityFromUI() {
      syncGravityLabels();
      world.gravity.set(Number(gx.value), Number(gy.value), Number(gz.value));
    }

    gx.addEventListener("input", applyGravityFromUI);
    gy.addEventListener("input", applyGravityFromUI);
    gz.addEventListener("input", applyGravityFromUI);

    function resetScene() {
      applyGravityFromUI();
      clearDominos();
      createDominos();
    }

    btnReset.addEventListener("click", resetScene);

    // -----------------------------
    // 初期構築
    // -----------------------------
    createGroundAndBorders();

    // 先に points を確定生成しておく（初回resetを軽くする）
    points = getSpiralPoints();

    resetScene();

    // -----------------------------
    // animate
    // -----------------------------
    let paused = false;
    btnPause.addEventListener("click", () => {
      paused = !paused;
      btnPause.textContent = paused ? "resume" : "pause";
    });

    const fixedDt = 1 / 60;
    let accumulator = 0;
    let lastTime = performance.now();

    let fpsAcc = 0;
    let fpsCount = 0;
    let fpsLast = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      fpsAcc += dt;
      fpsCount++;
      if (now - fpsLast >= 500) {
        const fps = fpsCount / fpsAcc;
        fpsEl.textContent = "FPS: " + fps.toFixed(1);
        fpsAcc = 0;
        fpsCount = 0;
        fpsLast = now;
      }

      if (!paused) {
        accumulator += dt;

        let subSteps = 0;
        const maxSubSteps = 5;

        while (accumulator >= fixedDt && subSteps < maxSubSteps) {
          world.step(fixedDt);
          accumulator -= fixedDt;
          subSteps++;
        }
      }

      for (const p of pairs) {
        const b = p.body;
        p.mesh.position.set(b.position.x, b.position.y, b.position.z);
        p.mesh.quaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;

      camera.aspect = w / h;
      camera.updateProjectionMatrix();

      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    });
  </script>
</body>
</html>