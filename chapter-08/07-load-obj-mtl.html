<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Example 08.07 - Load OBJ and MTL（NaNガード付き / ES Modules版 / assets使用）</title>

  <!--
    追加で起きたエラー：
      THREE.BufferGeometry.computeBoundingBox(): min/max have NaN
      THREE.BufferGeometry.computeBoundingSphere(): radius is NaN
      → “position attribute（頂点座標配列）に NaN/Infinity が混ざっている” ときに出る警告。

    ■ なぜ起きる？
      - OBJファイルの頂点データが壊れている/一部が NaN になっている
      - もしくは OBJ が想定外形式で、読み込み結果に異常値が入る
      - そして Box3.setFromObject() や renderer の内部が boundingBox/boundingSphere を計算する際に
        NaN が混ざっていると計算結果が NaN になり、警告が出る

    ■ この修正で何をする？
      1) 読み込んだ object を traverse して、各 Mesh の geometry.attributes.position を検査する
      2) position 配列に NaN/Infinity が1つでもあれば “壊れているMesh” と判断して
         - sceneに入れる前に除外（parent.remove(mesh)）
         - もしくは（最終手段として）NaN を 0 に置換する
      3) “正しい Mesh だけ” で boundingBox / boundingSphere を計算してから
         center / 接地などの調整を行う

    これで警告が止まり、描画も安定しやすくなる。
    ただし根本原因が assets のOBJ側にある場合は、Blender等で再exportするとさらに良い。
  -->

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body { margin: 0; overflow: hidden; background: #aaaaff; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    #hud {
      position: fixed;
      right: 12px;
      top: 12px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre;
      user-select: none;
    }
    #err {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 70, 70, 0.92);
      color: #fff;
      font-size: 12px;
      display: none;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <div id="hud">FPS: --</div>
  <div id="err"></div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
    import { MTLLoader } from "three/addons/loaders/MTLLoader.js";

    // -----------------------------
    // エラーを画面に出す（黒画面対策）
    // -----------------------------
    const errBox = document.getElementById("err");
    function showError(msg) { errBox.style.display = "block"; errBox.textContent = String(msg); }
    function clearError() { errBox.style.display = "none"; errBox.textContent = ""; }
    window.addEventListener("error", (e) => showError("window.onerror:\n" + (e?.error?.stack || e?.message || e)));
    window.addEventListener("unhandledrejection", (e) => showError("unhandledrejection:\n" + (e?.reason?.stack || e?.reason || e)));

    // -----------------------------
    // Scene / Camera / Renderer
    // -----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xaaaaff);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(-30, 40, 50);
    camera.lookAt(0, 10, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.dampingFactor = 0.08;
    orbit.target.set(0, 12, 0);
    orbit.update();

    // -----------------------------
    // 空間把握：グリッド & 地面（影の受け皿）
    // -----------------------------
    const grid = new THREE.GridHelper(400, 40);
    grid.material.opacity = 0.25;
    grid.material.transparent = true;
    scene.add(grid);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(600, 600),
      new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // -----------------------------
    // Light
    // -----------------------------
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));

    const spotLight = new THREE.SpotLight(0xffffff, 2.0);
    spotLight.position.set(0, 40, 30);
    spotLight.castShadow = true;
    spotLight.shadow.mapSize.set(1024, 1024);
    spotLight.shadow.camera.near = 1;
    spotLight.shadow.camera.far = 200;
    scene.add(spotLight);

    // -----------------------------
    // 破棄（GPUリーク防止）
    // -----------------------------
    function disposeObject3D(obj) {
      if (!obj) return;
      obj.traverse((node) => {
        if (!node.isMesh) return;
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) node.material.forEach((m) => m.dispose());
          else node.material.dispose();
        }
      });
    }

    // -----------------------------
    // “NaN position” ガード
    //
    // checkPositionFinite:
    //   geometry.attributes.position.array を走査して NaN/Infinity を検出する。
    //   1つでも見つかったら false。
    //
    // ※ OBJが重い場合は全走査がコストになるが、ここはロード時に1回だけなので問題になりにくい。
    // -----------------------------
    function checkPositionFinite(geometry) {
      const pos = geometry?.attributes?.position;
      if (!pos || !pos.array) return false;
      const arr = pos.array;
      for (let i = 0; i < arr.length; i++) {
        const v = arr[i];
        if (!Number.isFinite(v)) return false;
      }
      return true;
    }

    // 最終手段：NaNを0に置換して「警告だけでも止める」ための修復
    // ただし壊れたOBJだと形が崩れるので、基本は “除外” を優先する。
    function sanitizePositionReplaceNaNWithZero(geometry) {
      const pos = geometry?.attributes?.position;
      if (!pos || !pos.array) return false;
      const arr = pos.array;
      let replaced = 0;
      for (let i = 0; i < arr.length; i++) {
        const v = arr[i];
        if (!Number.isFinite(v)) {
          arr[i] = 0;
          replaced++;
        }
      }
      if (replaced > 0) {
        pos.needsUpdate = true;
      }
      return replaced > 0;
    }

    // -----------------------------
    // 羽の透過設定（“番号決め打ち”を廃止）
    // -----------------------------
    function configureWingMaterial(mesh) {
      const mat = mesh.material;
      if (!mat) return;

      mat.opacity = 0.6;
      mat.transparent = true;
      mat.side = THREE.DoubleSide;

      // 透過物の典型的トラブル（描画順/深度）を軽減するための設定
      // - depthWrite=false：透過が深度バッファに書き込むと奥が消える事故が増える
      // - depthTest=false：羽のような薄い板の“自己交差”が目立つ場合に見た目が安定しやすい
      mat.depthWrite = false;
      mat.depthTest = false;

      mat.needsUpdate = true;
    }

    function isWingCandidate(mesh) {
      const name = (mesh.name || "").toLowerCase();
      const matName = (mesh.material && mesh.material.name ? mesh.material.name.toLowerCase() : "");
      return name.includes("wing") || matName.includes("wing");
    }

    // -----------------------------
    // OBJ + MTL 読み込み（assetsを使う）
    // -----------------------------
    const ASSET_BASE = "../assets/models/";
    const MTL_FILE = "butterfly.mtl";
    const OBJ_FILE = "butterfly.obj";

    let model = null;

    const hud = document.getElementById("hud");

    const mtlLoader = new MTLLoader();
    mtlLoader.setPath(ASSET_BASE);

    mtlLoader.load(
      MTL_FILE,
      (materials) => {
        clearError();
        materials.preload();

        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath(ASSET_BASE);

        objLoader.load(
          OBJ_FILE,
          (object) => {
            // 既存モデルがあれば撤去＆解放
            if (model) {
              scene.remove(model);
              disposeObject3D(model);
              model = null;
            }

            // ---------------------------------------
            // 1) Meshを走査して「壊れている geometry」を除外/修復
            // ---------------------------------------
            const badMeshes = [];
            const allMeshes = [];

            object.traverse((node) => {
              if (!node.isMesh) return;
              allMeshes.push(node);

              // cast/receive shadow
              node.castShadow = true;
              node.receiveShadow = true;

              // 法線が無い場合だけ計算（陰影用）
              const geom = node.geometry;
              if (geom && geom.isBufferGeometry && !geom.attributes.normal) {
                geom.computeVertexNormals();
              }

              // 羽候補の透過設定
              if (isWingCandidate(node)) {
                configureWingMaterial(node);
              }

              // positionの有限性チェック
              if (!geom || !geom.isBufferGeometry || !geom.attributes.position) {
                // geometryが無いMeshは描画不能なので除外（念のため）
                badMeshes.push({ mesh: node, reason: "no position attribute" });
                return;
              }

              const ok = checkPositionFinite(geom);
              if (!ok) {
                // まずは “除外” を優先（根本が壊れている可能性が高い）
                // もし「どうしても全部出したい」なら、下の修復を有効化してもよい。
                badMeshes.push({ mesh: node, reason: "NaN/Infinity in position" });

                // --- 最終手段：NaNを0に置換して残す（必要ならコメントアウト解除） ---
                // const repaired = sanitizePositionReplaceNaNWithZero(geom);
                // if (repaired) {
                //   // 置換したなら bounding を再計算しておく
                //   geom.computeBoundingBox();
                //   geom.computeBoundingSphere();
                //   // bad扱いから外す（残す）場合は return しない
                //   return;
                // }
              } else {
                // 正常geometryだけ bounding を計算（renderer内部でも必要になる）
                // ※ ここで計算しておくと後の setFromObject などで余計な警告が出にくい
                geom.computeBoundingBox();
                geom.computeBoundingSphere();
              }
            });

            // 除外処理：親からremove（traverse中にremoveすると壊れやすいので後でまとめて行う）
            badMeshes.forEach(({ mesh }) => {
              if (mesh.parent) mesh.parent.remove(mesh);
            });

            if (badMeshes.length > 0) {
              console.warn("[OBJ NaN guard] removed bad meshes:", badMeshes.map(b => ({
                name: b.mesh.name,
                reason: b.reason,
              })));
            }

            // ---------------------------------------
            // 2) 見える値に調整（スケール/姿勢）
            // ---------------------------------------
            object.scale.set(140, 140, 140);
            object.rotation.x = 0.2;
            object.rotation.y = -1.3;

            // ---------------------------------------
            // 3) bboxで中心寄せ＆地面に接地
            //    ※ ここで setFromObject を呼ぶが、NaN mesh を除外済みなので警告が出にくい
            // ---------------------------------------
            const box = new THREE.Box3().setFromObject(object);
            const size = new THREE.Vector3();
            const center = new THREE.Vector3();
            box.getSize(size);
            box.getCenter(center);

            // もし size が NaN なら、まだ何かがおかしい（＝OBJが根本的に壊れている）
            if (![size.x, size.y, size.z, center.x, center.y, center.z].every(Number.isFinite)) {
              showError(
                "モデルのバウンディング計算が NaN になりました。\n" +
                "OBJに壊れた頂点が残っている可能性があります。\n" +
                "対処：OBJをBlender等で再エクスポート、または壊れているMeshを特定して除外してください。\n"
              );
            }

            object.position.sub(center);

            // 地面接地：minY を 0 に合わせる
            const box2 = new THREE.Box3().setFromObject(object);
            if (Number.isFinite(box2.min.y)) {
              object.position.y -= box2.min.y;
            }

            model = object;
            model.name = "butterfly_obj_mtl";
            scene.add(model);

            // ---------------------------------------
            // 4) カメラ/ターゲットの調整
            // ---------------------------------------
            const maxDim = Math.max(size.x, size.y, size.z) || 1;
            orbit.target.set(0, Math.max(size.y * 0.5, 8), 0);
            camera.position.set(-maxDim * 0.9, maxDim * 0.7, maxDim * 0.9);
            camera.lookAt(orbit.target);
            orbit.update();
          },
          (xhr) => {
            const total = xhr.total || 0;
            const loaded = xhr.loaded || 0;
            const pct = total ? (loaded / total) * 100 : 0;
            hud.textContent = total
              ? `Loading OBJ: ${pct.toFixed(1)}%`
              : `Loading OBJ: ${Math.round(loaded / 1024)} KB`;
          },
          (err) => {
            showError(
              "OBJ のロードに失敗しました。\n" +
              "確認ポイント:\n" +
              "- ../assets/models/butterfly.obj が存在するか\n" +
              "- ローカル直開きではなく http サーバで開いているか（CORS/制限回避）\n\n" +
              "詳細:\n" + (err?.message || err)
            );
          }
        );
      },
      (xhr) => {
        const total = xhr.total || 0;
        const loaded = xhr.loaded || 0;
        const pct = total ? (loaded / total) * 100 : 0;
        hud.textContent = total
          ? `Loading MTL: ${pct.toFixed(1)}%`
          : `Loading MTL: ${Math.round(loaded / 1024)} KB`;
      },
      (err) => {
        showError(
          "MTL のロードに失敗しました。\n" +
          "確認ポイント:\n" +
          "- ../assets/models/butterfly.mtl が存在するか\n" +
          "- MTL内で参照される画像ファイルが存在し、相対パスが正しいか\n" +
          "- ローカル直開きではなく http サーバで開いているか（CORS/制限回避）\n\n" +
          "詳細:\n" + (err?.message || err)
        );
      }
    );

    // -----------------------------
    // 簡易FPS
    // -----------------------------
    let lastFpsT = performance.now();
    let frames = 0;

    function animate() {
      requestAnimationFrame(animate);

      frames++;
      const now = performance.now();
      if (now - lastFpsT >= 1000) {
        const fps = (frames * 1000) / (now - lastFpsT);
        frames = 0;
        lastFpsT = now;
        hud.textContent =
          "FPS: " + fps.toFixed(1) + "\n" +
          "model: " + (model ? "loaded" : "loading...") + "\n" +
          "mtl: " + (ASSET_BASE + MTL_FILE) + "\n" +
          "obj: " + (ASSET_BASE + OBJ_FILE);
      }

      if (model) {
        model.rotation.y += 0.006;
      }

      orbit.update();
      renderer.render(scene, camera);
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.addEventListener("beforeunload", () => {
      disposeObject3D(model);
      ground.geometry.dispose();
      ground.material.dispose();
      renderer.dispose();
    });

    animate();
  </script>
</body>
</html>