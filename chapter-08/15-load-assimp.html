<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Example 08.15 - Load assimp model (legacy / AssimpJSONLoader)</title>

  <!--
    目的：
      - 旧Three.js(グローバルTHREE) + AssimpJSONLoader で
        「Assimpで変換された *.assimp.json モデル」を読み込み、表示・操作する。
      - “ロード → 下処理（材質/影/中心合わせ/床合わせ）→ sceneへ追加 → 毎フレーム描画”
        というアルゴリズムを理解できるようにコメント多めで整理する。

    このサンプルがやっている“全体アルゴリズム”（重要）
      1) Scene / Camera / Renderer を初期化して描画の土台を作る
      2) OrbitControls をセットし、ユーザー操作で視点を動かせるようにする
      3) ライトを置く（Lambert/Phong/Standard系はライトが無いと真っ黒）
      4) AssimpJSONLoader.load() で .assimp.json を非同期ロード
         - callback(model) で Object3D を受け取る
         - traverse() で子Meshを巡回し、materialや影設定を揃える
         - （任意）中心合わせ・床合わせ・スケール調整
         - scene.add(model)
      5) requestAnimationFrame の render loop を回し続ける
         - controls.update()
         - modelを回転（任意）
         - renderer.render()

    旧コードの問題点（今回の修正ポイント）
      - OrbitControls の生成が camera だけになっており、実装によっては domElement が必須
      - DirectionalLight の色/強度が省略され、環境によって暗くなる
      - group 変数が Object3D として作られているが、実際に回転させたいのはロードした model
        → “modelRoot” に一本化して混乱を減らす
      - Box3.getCenter が無いthree.js世代がある（前回の AWD と同じ）
        → getCenter互換関数で安全に中心合わせする
      - shadowMap.enabled だけでは影が出ない（ライト castShadow と メッシュ receive/cast も必要）
  -->

  <script type="text/javascript" src="../libs/three.js"></script>
  <script type="text/javascript" src="../libs/loaders/AssimpJSONLoader.js"></script>

  <script type="text/javascript" src="../libs/controls/OrbitControls.js"></script>
  <script type="text/javascript" src="../libs/stats.js"></script>
  <script type="text/javascript" src="../libs/dat.gui.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background: #000; }
  </style>
</head>

<body>
  <div id="Stats-output"></div>
  <div id="WebGL-output"></div>

  <script type="text/javascript">
    function init() {
      // -----------------------------
      // Stats（FPS表示）
      // -----------------------------
      var stats = initStats();

      // -----------------------------
      // Scene / Camera / Renderer
      // -----------------------------
      var scene = new THREE.Scene();

      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(30, 30, 30);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      var renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor(new THREE.Color(0x000000));
      renderer.setSize(window.innerWidth, window.innerHeight);

      // 影を使うなら renderer 側のスイッチをON
      renderer.shadowMap.enabled = true;

      document.getElementById("WebGL-output").appendChild(renderer.domElement);

      // -----------------------------
      // OrbitControls（旧版：camera + domElement）
      // -----------------------------
      var orbit = new THREE.OrbitControls(camera, renderer.domElement);
      if ("enableDamping" in orbit) orbit.enableDamping = true;
      if ("dampingFactor" in orbit) orbit.dampingFactor = 0.08;

      // -----------------------------
      // ライト
      // Lambert/Phong/Standard系はライトが必須。
      // 元コードは DirectionalLight() の引数が無く、暗くなる可能性があるため明示する。
      // -----------------------------
      var dir1 = new THREE.DirectionalLight(0xffffff, 0.6);
      dir1.position.set(-30, 30, -30);
      scene.add(dir1);

      var dir2 = new THREE.DirectionalLight(0xffffff, 0.6);
      dir2.position.set(-30, 30, 30);
      scene.add(dir2);

      var dir3 = new THREE.DirectionalLight(0xffffff, 0.6);
      dir3.position.set(30, 30, -30);
      scene.add(dir3);

      // 影用の主光源（SpotLight）
      var spotLight = new THREE.SpotLight(0xffffff, 1.2);
      spotLight.position.set(30, 30, 30);
      spotLight.castShadow = true;

      // 影の品質（重ければ下げる）
      if (spotLight.shadow && spotLight.shadow.mapSize) {
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
      }

      // ユーザー方針：SpotLight/PointLight の decay は 0（存在する場合のみ）
      if ("decay" in spotLight) spotLight.decay = 0;

      scene.add(spotLight);

      // 影を“受ける”床（モデルが浮いて見えない＆光の当たり方が分かりやすい）
      var floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshLambertMaterial({ color: 0x111111 })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // -----------------------------
      // dat.GUI：回転ON/OFFと速度
      // -----------------------------
      var controls = new (function () {
        this.autoRotate = true;
        this.rotateSpeed = 0.006;

        // materialをLambertに統一するか（モデルの見た目の比較用）
        this.forceLambert = true;

        // 影を使うか（重い場合の切り替え）
        this.enableShadow = true;
      })();

      var gui = new dat.GUI();
      gui.add(controls, "autoRotate");
      gui.add(controls, "rotateSpeed", 0.0, 0.05);
      gui.add(controls, "forceLambert");
      gui.add(controls, "enableShadow").onChange(function (v) {
        renderer.shadowMap.enabled = !!v;
      });

      // -----------------------------
      // Box3中心計算の互換関数（three.js世代差対策）
      // -----------------------------
      function getBoxCenterCompat(box, target) {
        target = target || new THREE.Vector3();

        if (typeof box.getCenter === "function") {
          return box.getCenter(target);
        }
        if (typeof box.center === "function") {
          var c = box.center();
          if (c && c.isVector3) {
            target.copy(c);
            return target;
          }
        }
        target.addVectors(box.min, box.max).multiplyScalar(0.5);
        return target;
      }

      // -----------------------------
      // モデル参照（ロード完了後に代入）
      // 旧コードの group は未使用だったので撤去し、modelRoot に統一する
      // -----------------------------
      var modelRoot = null;

      // -----------------------------
      // AssimpJSONLoader でロード
      //
      // “モデル読み込みのアルゴリズム” の要点：
      // - loader.load は非同期
      // - 完了 callback で Object3D を受け取り、scene に追加して初めて見える
      // - 追加前に traverse() で材質や影設定を揃えると安定する
      // -----------------------------
      var loader = new THREE.AssimpJSONLoader();
      loader.load(
        "../assets/models/assimp/spider.obj.assimp.json",
        function (model) {
          // 1) ロード完了：Object3D(階層)が来る
          modelRoot = model;

          // 2) traverse：子ノードを全走査して Mesh を見つける
          modelRoot.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
              // 影：投影/受け取り
              child.castShadow = true;
              child.receiveShadow = true;

              // 見た目を一定化したい場合は Lambert に差し替え（ライトで陰影が分かりやすい）
              if (controls.forceLambert) {
                child.material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
              }

              // Geometryの法線（古いGeometryなら計算可能、BufferGeometry中心だと無い場合あり）
              if (child.geometry) {
                if (typeof child.geometry.computeFaceNormals === "function") {
                  child.geometry.computeFaceNormals();
                }
                if (typeof child.geometry.computeVertexNormals === "function") {
                  child.geometry.computeVertexNormals();
                }
              }
            }
          });

          // 3) スケール調整（単位がバラバラなので「まず見える」ことを優先）
          modelRoot.scale.set(0.1, 0.1, 0.1);

          // 4) 中心合わせ（回転の軸が自然になる）
          // Box3.setFromObject が無いほど古いthree.jsならスキップ
          var box = new THREE.Box3();
          if (typeof box.setFromObject === "function") {
            box.setFromObject(modelRoot);

            var center = getBoxCenterCompat(box, new THREE.Vector3());
            modelRoot.position.sub(center);

            // 5) 床合わせ（min.y が 0 になるように）
            box.setFromObject(modelRoot);
            modelRoot.position.y -= box.min.y;
          } else {
            console.warn("Box3.setFromObject がありません。中心合わせ/床合わせをスキップします。");
          }

          // 6) シーンへ追加（これで描画ループで表示される）
          scene.add(modelRoot);
        },
        function (progressEvent) {
          // 進捗（必要なら）
          // console.log(progressEvent);
        },
        function (err) {
          console.error("AssimpJSON load failed:", err);
        }
      );

      // -----------------------------
      // Render loop
      // -----------------------------
      function render() {
        stats.update();
        orbit.update();

        // ロード済みなら回転
        if (modelRoot && controls.autoRotate) {
          modelRoot.rotation.y += controls.rotateSpeed;
        }

        requestAnimationFrame(render);
        renderer.render(scene, camera);
      }

      // -----------------------------
      // resize
      // -----------------------------
      window.addEventListener("resize", function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      render();

      // -----------------------------
      // Stats
      // -----------------------------
      function initStats() {
        var stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = "absolute";
        stats.domElement.style.left = "0px";
        stats.domElement.style.top = "0px";

        document.getElementById("Stats-output").appendChild(stats.domElement);
        return stats;
      }
    }

    window.onload = init;
  </script>
</body>
</html>