<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Example 06.02 - Advanced 3D geometries - Lathe (ES Modules + modernized + detailed comments)</title>

  <!--
    【このサンプルの目的】
    - 2Dの断面（Vector2の点列＝プロファイル）を「回転（旋盤: lathe）」させて 3D形状を作る。
      つまり「平面上の輪郭線を、Y軸まわりに回して立体を作る」アルゴリズムの可視化である。

    【古いコードからの主な修正点】
    - three.js を ES Modules + importmap に変更（window.THREE 依存をやめる）
    - dat.GUI → lil-gui、stats.js → stats.module.js（three/addons）
    - THREE.SceneUtils.createMultiMaterialObject は廃止されたため、Group + Mesh + LineSegments で代替
    - redraw 時に scene.remove だけでなく dispose() で GPU リソース解放（連打しても重くなりにくい）
    - resize 対応（カメラ/renderer 更新）
  -->

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>

<body>
  <div id="Stats-output"></div>
  <div id="WebGL-output"></div>

  <script type="module">
    import * as THREE from "three";
    import Stats from "three/addons/libs/stats.module.js";
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";

    // ============================================================
    // グローバル：描画ループ/リサイズで参照するもの
    // ============================================================
    let scene, camera, renderer, stats;

    // 「プロファイル点（赤い点）」と「Latheの立体」の表示物
    let profileGroup = null;   // 断面点の可視化（点群）
    let latheGroup = null;     // latheMesh（面） + wire（線）をまとめたGroup

    // アニメーション用
    let step = 0;

    // GUI の値（再生成に使う）
    const controls = {
      segments: 12,                // 回転方向の分割数（多いほど丸くなる）
      phiStart: 0,                 // 回転開始角（ラジアン）
      phiLength: Math.PI * 2,      // 回転角（2πで一周）

      showProfilePoints: true,     // 断面点を表示するか
      showWireframe: true,         // ワイヤ表示するか

      rotationSpeed: 0.01,         // 回転速度

      redraw: () => rebuild(),
    };

    // ============================================================
    // init：シーン構築 → 初回生成 → ループ開始
    // ============================================================
    function init() {
      // --- Stats（FPS表示）
      stats = initStats();

      // --- Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xeeeeee);

      // --- Camera
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(-30, 40, 50);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // --- Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById("WebGL-output").appendChild(renderer.domElement);

      // MeshNormalMaterial はライト不要だが、軸が分かりにくい場合があるので薄い補助グリッドを置く
      // （教材として「どこを回転軸にしているか」が分かりやすい）
      const grid = new THREE.GridHelper(120, 24);
      grid.position.y = -15;
      grid.material.opacity = 0.25;
      grid.material.transparent = true;
      scene.add(grid);

      // --- GUI（lil-gui）
      const gui = new GUI({ title: "Lathe Controls" });

      // segments は 3 以上が実用的（少ないと多角形感が強くなる）
      gui.add(controls, "segments", 3, 64, 1).name("segments").onChange(controls.redraw);

      gui.add(controls, "phiStart", 0, Math.PI * 2, 0.001).name("phiStart").onChange(controls.redraw);
      gui.add(controls, "phiLength", 0.001, Math.PI * 2, 0.001).name("phiLength").onChange(controls.redraw);

      gui.add(controls, "showProfilePoints").name("show profile points").onChange(() => {
        if (profileGroup) profileGroup.visible = controls.showProfilePoints;
      });

      gui.add(controls, "showWireframe").name("show wireframe").onChange(() => {
        if (latheGroup) {
          const wire = latheGroup.getObjectByName("latheWire");
          if (wire) wire.visible = controls.showWireframe;
        }
      });

      gui.add(controls, "rotationSpeed", 0, 0.1, 0.001).name("rotationSpeed");
      gui.add(controls, "redraw").name("rebuild");

      // --- 初回生成
      rebuild();

      // --- リサイズ対応
      window.addEventListener("resize", onResize);

      // --- ループ開始
      render();
    }

    // ============================================================
    // Lathe の「入力（プロファイル点）」を作る
    // ============================================================
    function buildProfilePoints() {
      /*
        【アルゴリズム：プロファイル点列（Vector2）】
        - LatheGeometry は「2D断面（x,y）」を入力に取り、その断面を Y軸まわりに回転して 3Dメッシュを作る。
        - 入力の点列 points は、x>=0 側に置くのが自然（回転すると半径になるため）。
          ※ x が負になると回転後に自己交差っぽい形になり得る（教材としてはアリだが注意）。

        ここでは「sin/cos の合成」で半径がゆらぐ輪郭を作っている。
        y は上から下まで（count 個）並べ、x はゆらぐ半径として使う。
      */
      const points = [];
      const height = 5;   // 半径のゆらぎ強さ
      const count = 30;   // 断面点の数（縦方向の解像度）

      for (let i = 0; i < count; i++) {
        // 半径（x）：sin/cos を混ぜて「くびれ/ふくらみ」を作る
        const radius =
          (Math.sin(i * 0.2) + Math.cos(i * 0.3)) * height + 12;

        // 高さ（y）：上から下へ並べる（中心が 0 付近になるようシフト）
        const y = (i - count) + count / 2;

        points.push(new THREE.Vector2(radius, y));
      }

      return points;
    }

    // ============================================================
    // プロファイル点（赤点）を可視化するオブジェクトを作る
    // ============================================================
    function createProfilePointsObject(points) {
      /*
        【可視化の狙い】
        - Lathe は「この2D断面を回してるだけ」という理解が重要なので、
          断面点を赤い点で表示して「入力」を目で見えるようにする。

        【実装】
        - 点の数は多くても数十なので Mesh を複数でも動くが、
          教材として「点数増やしても崩れにくい」よう InstancedMesh を採用。
      */

      const group = new THREE.Group();
      group.name = "profileGroup";

      // 点を「メッシュとして描く」ための小球
      const sphereGeom = new THREE.SphereGeometry(0.25, 10, 10);
      const sphereMat  = new THREE.MeshBasicMaterial({ color: 0xff0000 });

      const inst = new THREE.InstancedMesh(sphereGeom, sphereMat, points.length);

      // 各点の位置を instanceMatrix に書き込む
      const dummy = new THREE.Object3D();
      for (let i = 0; i < points.length; i++) {
        dummy.position.set(points[i].x, points[i].y, 0);
        dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
      }
      inst.instanceMatrix.needsUpdate = true;

      group.add(inst);

      // 断面点は latheMesh と重なると見づらいので、少し左にオフセットして「横に並べて」見せる
      group.position.set(-30, 0, 0);

      return group;
    }

    // ============================================================
    // Lathe（面+ワイヤ）を作る
    // ============================================================
    function createLatheObject(points, segments, phiStart, phiLength) {
      /*
        【アルゴリズム：LatheGeometry】
        - points: 断面（x,y）の点列
        - segments: 回転方向の分割数（多いほど滑らか）
        - phiStart/phiLength: 回転の開始角と回転量
          例）phiLength = π なら「半分だけ回した形（半円旋盤）」になる

        LatheGeometry は内部で：
        - 各 points[i]（半径 r=x、高さ y）を角度 φ ごとに回転して 3D座標に変換
        - φ のサンプル数が segments
        - その格子（i, φ）を三角形でつないで面（インデックス）を作る
        という構築を行っている。
      */

      // 安全のため、値を最低限クランプする（壊れた入力で真っ黒/NaN になりがち）
      const seg = Math.max(3, Math.floor(segments));
      const start = phiStart;
      const length = Math.max(0.0001, Math.min(phiLength, Math.PI * 2));

      const geom = new THREE.LatheGeometry(points, seg, start, length);

      // 面：法線を色として表示（ライト不要で「形状の曲率」が分かりやすい）
      const meshMat = new THREE.MeshNormalMaterial({
        side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(geom, meshMat);
      mesh.name = "latheMesh";

      // ワイヤ：辺だけ表示（輪郭が掴みやすい）
      const wireGeom = new THREE.WireframeGeometry(geom);
      const wireMat  = new THREE.LineBasicMaterial({ color: 0x222222 });
      const wire = new THREE.LineSegments(wireGeom, wireMat);
      wire.name = "latheWire";
      wire.visible = controls.showWireframe;

      // まとめてGroupにして、回転などの操作を一括でかける
      const group = new THREE.Group();
      group.name = "latheGroup";
      group.add(mesh);
      group.add(wire);

      // 断面点を左に寄せているので、lathe は原点周りに置いて見比べやすくする
      group.position.set(0, 0, 0);

      return group;
    }

    // ============================================================
    // rebuild：GUI操作のたびに「入力→lathe再構築」をやり直す
    // ============================================================
    function rebuild() {
      // 既存オブジェクトの削除（scene.remove だけだと GPU リソースは残るので dispose もする）
      if (profileGroup) {
        disposeObject3D(profileGroup);
        scene.remove(profileGroup);
        profileGroup = null;
      }
      if (latheGroup) {
        disposeObject3D(latheGroup);
        scene.remove(latheGroup);
        latheGroup = null;
      }

      // 入力（断面点）を作る
      const points = buildProfilePoints();

      // 入力可視化（赤点）
      profileGroup = createProfilePointsObject(points);
      profileGroup.visible = controls.showProfilePoints;
      scene.add(profileGroup);

      // 出力（旋盤メッシュ）
      latheGroup = createLatheObject(points, controls.segments, controls.phiStart, controls.phiLength);
      scene.add(latheGroup);
    }

    // ============================================================
    // render：毎フレーム
    // ============================================================
    function render() {
      stats.update();

      step += controls.rotationSpeed;

      // 「入力（断面点）」と「出力（lathe）」を同じ角度で回すと対応関係が分かりやすい
      if (profileGroup) profileGroup.rotation.x = step;
      if (latheGroup)   latheGroup.rotation.x   = step;

      requestAnimationFrame(render);
      renderer.render(scene, camera);
    }

    // ============================================================
    // リサイズ
    // ============================================================
    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    // ============================================================
    // Stats 初期化
    // ============================================================
    function initStats() {
      const s = new Stats();
      s.showPanel(0); // 0: fps
      s.dom.style.position = "absolute";
      s.dom.style.left = "0px";
      s.dom.style.top = "0px";
      document.getElementById("Stats-output").appendChild(s.dom);
      return s;
    }

    // ============================================================
    // dispose：GPU リソース解放（重要）
    // ============================================================
    function disposeObject3D(root) {
      /*
        three.js は scene.remove() しても、Geometry / Material / Texture は自動で破棄されない。
        GUIで何度も作り直すサンプルは dispose を入れないと「だんだん重くなる」原因になる。
      */
      root.traverse((obj) => {
        // Mesh / LineSegments の geometry/material を安全に破棄
        if (obj.geometry) {
          obj.geometry.dispose();
        }

        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach((m) => m && m.dispose && m.dispose());
          } else {
            obj.material.dispose && obj.material.dispose();
          }
        }
      });
    }

    // 起動
    window.addEventListener("load", init);
  </script>
</body>
</html>