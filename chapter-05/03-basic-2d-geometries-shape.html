<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Example 05.03 - Basic 2D geometries - Shape (ES Modules + fixed modern APIs)</title>

  <!--
    =========================
    このファイルの目的
    =========================
    - THREE.Shape を使って「2Dの輪郭（外周）」＋「穴（holes）」を持つ形状を定義し、
      それを
        (1) 面（ShapeGeometry → Mesh）
        (2) 点列の線（getPoints / getSpacedPoints → Line）
      の2通りで可視化して、違いを観察できるようにする。

    =========================
    旧コードからの主な修正点
    =========================
    1) three.js を ES Modules + importmap で読み込み（window.THREE 前提をやめる）
    2) dat.gui -> lil-gui、stats.js -> stats.module.js（three/examples）
    3) THREE.SceneUtils.createMultiMaterialObject は廃止されているため使用しない
       - 代わりに Group を作り、Mesh（面）と LineSegments（ワイヤ）を自前で束ねる
    4) shape.createPointsGeometry / createSpacedPointsGeometry は古いAPIで環境差が出るため使わない
       - 代わりに shape.getPoints(n) / getSpacedPoints(n) を使い、BufferGeometry を自前生成する
    5) GUIで表示切替を繰り返すので、古いオブジェクトの geometry/material を dispose してGPUリークを防ぐ
    6) resize 対応を追加（画面サイズ変更に追従）

    =========================
    アルゴリズム（全体の流れ）
    =========================
    init():
      - Scene/Camera/Renderer/Stats/GUIを作る
      - Shape（輪郭+穴）を buildShape() で作る
      - 表示モードに応じて Object3D（Mesh or Line）を生成して scene に add
      - requestAnimationFrame で毎フレーム回転+描画

    表示切替（GUIのボタン）:
      - 既存の表示 Object3D を scene から remove
      - disposeObject3D() でGPUリソースを解放
      - 新しい表示 Object3D を生成して scene に add

    =========================
    注意（WebGLの線の太さ）
    =========================
    - LineBasicMaterial の linewidth は多くの環境で 1 以外が効かない（WebGLの制約）
      ここでは「設定はしても実質 1 のことがある」という前提で扱う。
  -->

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>

<body>
  <div id="Stats-output"></div>
  <div id="WebGL-output"></div>

  <script type="module">
    import * as THREE from "three";
    import Stats from "three/addons/libs/stats.module.js";
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";

    // ============================================================
    // 共有（render/resize/GUI切替で参照する）
    // ============================================================
    let scene, camera, renderer, stats;
    let currentObject = null;   // 現在表示している Object3D（Mesh/Line/Group のどれか）
    let step = 0;

    // ============================================================
    // init: 初期化
    // ============================================================
    function init() {
      // ---- Stats（FPS表示）----
      stats = initStats();

      // ---- Scene ----
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xeeeeee);

      // ---- Camera ----
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(-30, 70, 70);
      camera.lookAt(new THREE.Vector3(10, 0, 0));

      // ---- Renderer ----
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById("WebGL-output").appendChild(renderer.domElement);

      // ---- Light（このサンプルでは必須ではないが“教材テンプレ感”を残す）----
      // MeshNormalMaterial はライトに影響されないので、見た目は変わらない。
      // ただ、将来 material を変えたときに真っ黒になる事故を減らすために弱い環境光を入れておく。
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));
      const spotLight = new THREE.SpotLight(0xffffff, 0.6);
      spotLight.position.set(-40, 60, -10);
      // ※影はこのサンプルの要件ではないので shadow はオフのまま
      scene.add(spotLight);

      // ---- 最初の表示（面 + ワイヤ）----
      setMode("geom");

      // ---- GUI（表示モード切替）----
      const controls = {
        mode: "geom",
        // 「asGeom/asPoints/asSpacedPoints」の旧GUI構造を “mode” 1つに整理
        // - geom: ShapeGeometry を Mesh 化（面+ワイヤ）
        // - points: getPoints を Line 化（輪郭の点列）
        // - spaced: getSpacedPoints を Line 化（等間隔っぽい点列）
      };

      const gui = new GUI({ title: "Shape controls" });
      gui.add(controls, "mode", ["geom", "points", "spaced"])
        .name("表示モード")
        .onChange((v) => setMode(v));

      // ---- Resize ----
      window.addEventListener("resize", onResize);

      // ---- Render loop ----
      render();
    }

    // ============================================================
    // buildShape: サンプル形状（外周 + 穴）を作る
    // ============================================================
    function buildShape() {
      // THREE.Shape は「2Dの輪郭」を定義するクラス
      // - moveTo/lineTo/bezierCurveTo/quadraticCurveTo などで外周を描く
      // - holes に THREE.Path を追加すると “穴あき形状” になる
      const shape = new THREE.Shape();

      // startpoint
      shape.moveTo(10, 10);

      // straight line upwards
      shape.lineTo(10, 40);

      // the top of the figure, curve to the right（ベジェ曲線）
      shape.bezierCurveTo(15, 25, 25, 25, 30, 40);

      // spline back down（滑らかな補間曲線）
      shape.splineThru([
        new THREE.Vector2(32, 30),
        new THREE.Vector2(28, 20),
        new THREE.Vector2(30, 10),
      ]);

      // curve at the bottom（二次ベジェ）
      shape.quadraticCurveTo(20, 15, 10, 10);

      // ---- holes（穴）----
      // 目の穴 1
      const hole1 = new THREE.Path();
      hole1.absellipse(16, 24, 2, 3, 0, Math.PI * 2, true);
      shape.holes.push(hole1);

      // 目の穴 2
      const hole2 = new THREE.Path();
      hole2.absellipse(23, 24, 2, 3, 0, Math.PI * 2, true);
      shape.holes.push(hole2);

      // 口（半円の穴）
      const hole3 = new THREE.Path();
      hole3.absarc(20, 16, 2, 0, Math.PI, true);
      shape.holes.push(hole3);

      return shape;
    }

    // ============================================================
    // buildGeomObject: ShapeGeometry を Mesh 化（面 + ワイヤ）
    // ============================================================
    function buildGeomObject(shape) {
      // ShapeGeometry は「2D shape を三角形メッシュに分割（tessellation）して面にする」
      // つまり内部的には “ポリゴンの三角形分割” が走る
      const geom = new THREE.ShapeGeometry(shape);

      // 面：法線方向を色で表示（教材として“面の向き”が分かりやすい）
      const faceMat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geom, faceMat);

      // ワイヤ：WireframeGeometry を使うと “三角形分割されたエッジ” が可視化できる
      const wireGeom = new THREE.WireframeGeometry(geom);
      const wireMat = new THREE.LineBasicMaterial({ color: 0x111111 });

      const wire = new THREE.LineSegments(wireGeom, wireMat);

      // 面とワイヤをまとめる（旧 SceneUtils.createMultiMaterialObject 相当）
      const group = new THREE.Group();
      group.add(mesh);
      group.add(wire);

      // 位置調整：この shape は (10..32) 付近に座標があるので、原点付近に寄せる
      // ※教材的に「カメラ中心へ置く」方が分かりやすいので平行移動する
      group.position.set(-20, 0, -20);

      return group;
    }

    // ============================================================
    // buildLineObject: 点列（輪郭）を Line として描く
    // ============================================================
    function buildLineObject(shape, spaced) {
      // shape.getPoints(n):
      //   - 曲線を n に応じてサンプリングし “点列” を返す（均一パラメータではない）
      // shape.getSpacedPoints(n):
      //   - “距離”の観点でなるべく等間隔っぽく点を取ろうとする
      // どちらも「形状の輪郭の離散化」を観察する教材になる
      const points2D = spaced ? shape.getSpacedPoints(50) : shape.getPoints(50);

      // THREE.Line は 3D座標の列が必要なので、(x, y) を (x, 0, y) に展開する
      const points3D = points2D.map((p) => new THREE.Vector3(p.x, 0, p.y));

      // “閉じた輪郭”にしたいので最後に先頭を足す（LineLoopでも良いが教材上明示）
      if (points3D.length > 0) points3D.push(points3D[0].clone());

      const geom = new THREE.BufferGeometry().setFromPoints(points3D);

      // 線の色は旧コードに合わせて赤寄り
      const mat = new THREE.LineBasicMaterial({
        color: 0xff3333,
        linewidth: 2 // WebGLでは効かないことが多い（注意）
      });

      const line = new THREE.Line(geom, mat);

      // 位置調整（面と同じ）
      line.position.set(-20, 0, -20);

      return line;
    }

    // ============================================================
    // setMode: 表示モードを切り替える（GUIから呼ばれる）
    // ============================================================
    function setMode(mode) {
      // 1) 既存表示をシーンから外し、GPUリソースを解放
      if (currentObject) {
        scene.remove(currentObject);
        disposeObject3D(currentObject);
        currentObject = null;
      }

      // 2) Shape を作り直す（今回のサンプルは固定形状なので毎回同じだが、
      //    将来パラメータ化したくなったときにここが拡張点になる）
      const shape = buildShape();

      // 3) モードに応じて描画オブジェクトを生成
      if (mode === "geom") {
        currentObject = buildGeomObject(shape);
      } else if (mode === "points") {
        currentObject = buildLineObject(shape, false);
      } else if (mode === "spaced") {
        currentObject = buildLineObject(shape, true);
      }

      // 4) シーンへ追加
      scene.add(currentObject);
    }

    // ============================================================
    // disposeObject3D: scene から remove した Object3D の後片付け
    // ============================================================
    function disposeObject3D(root) {
      // GUIで何度も作り直すと、dispose しない限り geometry/material がGPUに残る。
      // 「目に見えないけど重くなる」典型的な落とし穴なので必ず入れる。
      root.traverse((obj) => {
        if (obj.geometry) obj.geometry.dispose();

        // material は単体/配列どちらもありうるので両対応
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach((m) => m.dispose && m.dispose());
          } else {
            obj.material.dispose && obj.material.dispose();
          }
        }
      });
    }

    // ============================================================
    // render: 毎フレームの更新（回転 + 描画）
    // ============================================================
    function render() {
      stats.update();

      // “形状”は2Dで平たいので、回転させると立体的に観察できる
      step += 0.01;
      if (currentObject) currentObject.rotation.y = step;

      requestAnimationFrame(render);
      renderer.render(scene, camera);
    }

    // ============================================================
    // resize: 画面サイズが変わったらカメラとレンダラを更新
    // ============================================================
    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    // ============================================================
    // stats: FPS表示の初期化
    // ============================================================
    function initStats() {
      const s = new Stats();
      s.showPanel(0); // 0: fps
      s.dom.style.position = "absolute";
      s.dom.style.left = "0px";
      s.dom.style.top = "0px";
      document.getElementById("Stats-output").appendChild(s.dom);
      return s;
    }

    window.onload = init;
  </script>
</body>
</html>